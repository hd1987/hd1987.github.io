{"posts":[{"title":"base.css","text":"常用的base.css初始化样式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798@charset &quot;UTF-8&quot;;* { margin: 0; padding: 0; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); -webkit-tap-highlight-color: transparent;}html, body { color: #333; background: #fff; line-height: 1.2;}a { color: #D7171F;}a:hover { color: #D7171F; text-decoration: none;}html { -webkit-font-smoothing: antialiased;}body,button,input,select,textarea { font-family: Arial, Helvetica, sans-serif; font-size: 16px;}button,input,select { vertical-align: middle; outline: none;}textarea { outline: none; resize: none;}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder { color: #b3b3b3;}input:-moz-placeholder,textarea:-moz-placeholder { color: #b3b3b3;}input::-moz-placeholder,textarea::-moz-placeholder { color: #b3b3b3;}input:-ms-input-placeholder,textarea:-ms-input-placeholder { color: #b3b3b3;}/*::-webkit-scrollbar{width:5px;}::-webkit-scrollbar-track{background-color:#fff;}::-webkit-scrollbar-thumb{background-color:#ccc; border-radius:4px;}::-webkit-scrollbar-thumb:hover {background-color:#ccc}::-webkit-scrollbar-thumb:active {background-color:#ccc}*/table { border-collapse: collapse; border-spacing: 0;}img { border: 0;}ol,ul { list-style: none;}.clearfix:after { visibility: hidden; display: block; font-size: 0; content: &quot; &quot;; clear: both; height: 0;}","link":"/2016/10/10/css-base/"},{"title":"css3 flex弹性布局摘要","text":"Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性 设为Flex布局以后，子元素的float、clear和vertical-align属性将失效 12345678910111213141516171819.box{ display: -webkit-flex; /* -webkit */ display: flex; flex-direction: row | row-reverse | column | column-reverse; /* row */ flex-wrap: nowrap | wrap | wrap-reverse; /* nowrap */ flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; /* row nowrap */ justify-content: flex-start | flex-end | center | space-between | space-around; /* flex-start */ align-items: flex-start | flex-end | center | baseline | stretch; /* stretch */ align-content: flex-start | flex-end | center | space-between | space-around | stretch; /* stretch */}.item { order: &lt;integer&gt;; /* 0 */ flex-grow: &lt;number&gt;; /* 0 */ flex-shrink: &lt;number&gt;; /* 1 */ flex-basis: &lt;length&gt; | auto; /* auto */ flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]; /* 0 1 auto */ align-self: auto | flex-start | flex-end | center | baseline | stretch; /* auto */} 容器属性flex-direction决定主轴的方向（即项目的排列方向） row（默认值）: 主轴为水平方向，起点在左端row-reverse: 主轴为水平方向，起点在右端column: 主轴为垂直方向，起点在上沿column-reverse: 主轴为垂直方向，起点在下沿 flex-wrap如果一条轴线排不下，如何换行 nowrap（默认）: 不换行wrap: 换行，第一行在上方wrap-reverse: 换行，第一行在下方 flex-flow是flex-direction属性和flex-wrap属性的简写形式 默认值为row nowrap justify-content项目在主轴上的对齐方式 flex-start（默认值）: 左对齐flex-end: 右对齐center: 居中space-between: 两端对齐，项目之间的间隔都相等space-around: 每个项目两侧的间隔相等，项目之间的间隔比项目与边框的间隔大一倍 align-items项目在交叉轴上如何对齐 flex-start: 顶部对齐flex-end: 底部对齐center: 中间对齐baseline: 项目的第一行文字的基线对齐stretch（默认值）: 如果项目未设置高度或设为auto，将占满整个容器的高度 align-content多根轴线的对齐方式如果项目只有一根轴线，该属性不起作用 flex-start: 顶部对齐flex-end: 底部对齐center: 中间对齐space-between: 与交叉轴两端对齐，轴线之间的间隔平均分布space-around: 每根轴线两侧的间隔都相等，轴线之间的间隔比轴线与边框的间隔大一倍stretch（默认值）: 轴线占满整个交叉轴 项目属性order 默认为0 项目的排列顺序数值越小，排列越靠前 flex-grow 默认为0, 即如果存在剩余空间，也不放大 项目的放大比例 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话），如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍 flex-shrink 默认为1，即如果空间不足，该项目将缩小 项目的缩小比例 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小，如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小负值对该属性无效 flex-basis 默认值为auto，即项目的本来大小 在分配多余空间之前，项目占据的主轴空间（main size），浏览器根据这个属性，计算主轴是否有多余空间它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间 flex 默认值为0 1 auto，后两个属性可选 flex属性是flex-grow, flex-shrink 和 flex-basis的简写 align-self 默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性该属性可能取6个值，除了auto，其他都与align-items属性完全一致","link":"/2018/08/07/css-flex/"},{"title":"自定义字体 @font-face","text":"12345678910111213@font-face { font-family: 'MyWebFont'; src: url('webfont.eot'); /* IE9 Compat Modes */ src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('webfont.woff2') format('woff2'), /* Super Modern Browsers */ url('webfont.woff') format('woff'), /* Pretty Modern Browsers */ url('webfont.ttf') format('truetype'), /* Safari, Android, iOS */ url('webfont.svg#svgFontName') format('svg'); /* Legacy iOS */}body { font-family: 'MyWebFont', Fallback, sans-serif;} Practical Level of Browser Support12345@font-face { font-family: 'MyWebFont'; src: url('myfont.woff2') format('woff2'), url('myfont.woff') format('woff');} Chrome Safari Firefox Opera IE Android iOS 5+ 5.1+ 3.6+ 11.50+ 9+ 4.4+ 5.1+ Slightly Deeper Browser Support123456@font-face { font-family: 'MyWebFont'; src: url('myfont.woff2') format('woff2'), url('myfont.woff') format('woff'), url('myfont.ttf') format('truetype');} Chrome Safari Firefox Opera IE Android iOS 3.5+ 3+ 3.5+ 10.1+ 9+ 2.2+ 4.3+ Super Progressive Browser Support1234@font-face { font-family: 'MyWebFont'; src: url('myfont.woff2') format('woff2');} Chrome Safari Firefox Opera IE Android iOS 36+ No 35+ with flag 23+ No 37 No","link":"/2017/04/28/css-font-face/"},{"title":"IE6 png图片透明的2种方法","text":"一.图片当背景，CSS方法 1234img { _background:none; _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='logo.png',sizingMethod='crop'); } 但是测试发现当给background:red url(logo.png) no-repeat center;加了红色时，别的浏览器正常识别，ie6会出现依旧不识别的情况。解决办法是在外面套的标签，或body加背景色。（background-color:red;单独写就可以了）强调：IE6做了透明的背景，对他上面&lt;A&gt;便签会失效，也就是点有连接的地方没连接了，解决方案：列&lt;div class=&quot;top&quot;&gt;&lt;a&gt;首页&lt;/a&gt; &lt;a&gt;关于我们&lt;/a&gt; &lt;a&gt;产品中心&lt;/a&gt;...&lt;/div&gt;，如果top这个class有PNG背景，而你又用了我那个代码，这个时候里面的链接会没反映的，解决就是:.top a{position:relative}，这个很常用了 二.图片插入，也就是&lt;img src=&quot;&quot; /&gt;这种形式，试用JS方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt;function correctPNG() { for(var i=0; i&lt;document.images.length; i++) { var img = document.images[i] var imgName = img.src.toUpperCase() if (imgName.substring(imgName.length-3, imgName.length) == &quot;PNG&quot;) { var imgID = (img.id) ? &quot;id='&quot; + img.id + &quot;' &quot; : &quot;&quot; var imgClass = (img.className) ? &quot; &quot; : &quot;&quot; var imgTitle = (img.title) ? &quot;title='&quot; + img.title + &quot;' &quot; : &quot;title='&quot; + img.alt + &quot;' &quot; var imgStyle = &quot;display:inline-block;&quot; + img.style.cssText if (img.align == &quot;left&quot;) imgStyle = &quot;float:left;&quot; + imgStyle if (img.align == &quot;right&quot;) imgStyle = &quot;float:right;&quot; + imgStyle if (img.parentElement.href) imgStyle = &quot;cursor:hand;&quot; + imgStyle var strNewHTML = &quot;&lt;span &quot; + imgID + imgClass + imgTitle + &quot; style=\\&quot;&quot; + &quot;width:&quot; + img.width + &quot;px; height:&quot; + img.height + &quot;px;&quot; + imgStyle + &quot;;&quot; + &quot;filter:progid:DXImageTransform.Microsoft.AlphaImageLoader&quot; + &quot;(src=\\'&quot; + img.src + &quot;\\', sizingMethod='scale');\\&quot;&gt;&lt;/span&gt;&quot; img.outerHTML = strNewHTML i = i-1 } } }window.attachEvent(&quot;onload&quot;, correctPNG);if (navigator.platform == &quot;Win32&quot; &amp;&amp; navigator.appName == &quot;Microsoft Internet Explorer&quot; &amp;&amp; window.attachEvent) { window.attachEvent(&quot;onload&quot;, alphaBackgrounds);}function alphaBackgrounds(){ var rslt = navigator.appVersion.match(/MSIE (d+.d+)/, ''); var itsAllGood = (rslt != null &amp;&amp; Number(rslt[1]) &gt;= 5.5); for (i=0; i&lt;document.all.length; i++){ var bg = document.all[i].currentStyle.backgroundImage; if (itsAllGood &amp;&amp; bg){ if (bg.match(/.png/i) != null){ var mypng = bg.substring(5,bg.length-2); document.all[i].style.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(src='&quot;+mypng+&quot;', sizingMethod='scale')&quot;; document.all[i].style.backgroundImage = &quot;url('')&quot;; } } }}alphaBackgrounds();&lt;/script&gt;","link":"/2016/03/25/css-ie6png/"},{"title":"css控制 外层div高度未知 内层div高度100%","text":"外层：div设置超出不显示，内层：div底部内边距10000px，div底部外边距-10000px。 12.outerDiv { overflow:hidden;}.interDiv { padding-bottom:10000px; margin-bottom:-10000px;}","link":"/2016/03/24/css-interdiv/"},{"title":"去除ios中input默认样式","text":"12345input,textarea,select,button { -webkit-appearance: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); border-radius:0;}","link":"/2016/03/25/css-ios-input-default/"},{"title":"div设置最小高度（兼容IE6）","text":"12345.test { height:auto!important; height:200px; min-height:200px;} 标准浏览器中固定高度值的容器是不会象IE6里那样被撑开的,那我又想固定高度，又想能被撑开需要怎样设置呢？办法就是去掉height设置min-height:200px; 这里为了照顾不认识min-height的IE6 可以这样定义","link":"/2016/03/25/css-min-height/"},{"title":"css透明度设置opacity","text":"123456.opacity{ filter:alpha(opacity=50); /* IE */ opacity:0.5; /* 支持opacity的浏览器*/ -moz-opacity:0.5; /* 老版Mozilla */ -khtml-opacity:0.5; /* 老版Safari */}","link":"/2016/03/24/css-opacity/"},{"title":"文字超出范围以省略号表示","text":"一、单行溢出，超出部分显示…或者截取。前提必须有宽度。1p { width:100px; overflow:hidden; white-space:nowrap; text-overflow:ellipsis;} 二、多行溢出1p { display:-webkit-box; overflow:hidden; text-overflow:ellipsis; -webkit-line-clamp:2; -webkit-box-orient:vertical;} 适用范围：因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端；说明：1.-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：2.display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。3.-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 三、移动端1234567p{position: relative; line-height: 20px; max-height: 40px;overflow: hidden;} p::after{content: &quot;...&quot;; position: absolute; bottombottom: 0; rightright: 0; padding-left: 40px; background: -webkit-linear-gradient(left, transparent, #fff 55%); background: -o-linear-gradient(rightright, transparent, #fff 55%); background: -moz-linear-gradient(rightright, transparent, #fff 55%); background: linear-gradient(to rightright, transparent, #fff 55%); } 适用范围：该方法适用范围广，但文字未超出行的情况下也会出现省略号,可结合js优化该方法。说明：1.将height设置为line-height的整数倍，防止超出的文字露出。2.给p::after添加渐变背景可避免文字只显示一半。3.由于ie6-7不显示content内容，所以要添加标签兼容ie6-7（如：&lt;span&gt;…&lt;span/&gt;）；兼容ie8需要将::after替换成:after。","link":"/2016/03/24/css-overflow/"},{"title":"html5默认提示文字placeholder更改颜色","text":"12345/* placeholder颜色 */input::-webkit-input-placeholder, textarea::-webkit-input-placeholder { color: #dbdbdb;}input:-moz-placeholder, textarea:-moz-placeholder { color: #dbdbdb;}input::-moz-placeholder, textarea::-moz-placeholder { color: #dbdbdb;}input:-ms-input-placeholder, textarea:-ms-input-placeholder { color: #dbdbdb;}","link":"/2016/03/24/css-placeholder/"},{"title":"Retina屏幕下border 1px解决方案","text":"retinal屏幕下@2x, @3x会使css设定好的border 1px变成2倍或者3倍。以@2x为例，用css解决这个放大的问题（此方法能解决直线） 12345678910111213.scale{ position: relative;}.scale:after{ content: ''; position: absolute; bottom: 0; left: 0; right: 0; border-bottom: 1px solid #ddd; -webkit-transform: scaleY(.5); -webkit-transform-origin: 0 0;}","link":"/2016/10/03/css-retinal-border/"},{"title":"sass - Retinal屏border显示1px","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@mixin border($top, $right, $bottom, $left, $color:#f00) { content: &quot; &quot;; position: absolute; top: $top; right: $right; bottom: $bottom; left: $left; color: $color; $position: ''; $transform-origin: ''; $scale: ''; @if $top == 'auto' or $bottom == 'auto' { height: 1px; $scale: 1, .5; } @else if $left == 'auto' or $right == 'auto' { width: 1px; $scale: .5, 1; } @if $top == 'auto' { $position: bottom; $transform-origin: 0 100%; } @else if $right == 'auto' { $position: left; $transform-origin: 0 0; } @else if $bottom == 'auto' { $position: top; $transform-origin: 0 0; } @else if $left == 'auto' { $position: right; $transform-origin: 100% 0; } border-#{$position} : 1px solid $color; -webkit-transform-origin: $transform-origin; transform-origin: $transform-origin; -webkit-transform: scale($scale); transform: scale($scale); z-index: 1;}.demo { position: relative; &amp;:before { @include border(0, 0, auto, 0, #666); // top, right, bottom, left, color }}","link":"/2016/12/06/css-sass-border/"},{"title":"SASS用法指南","text":"一、什么是SASSSASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。 二、安装和使用2.1 安装 SASS是Ruby语言写的，但是两者的语法没有关系。不懂Ruby，照样使用。只是必须先安装Ruby，然后再安装SASS。 假定你已经安装好了Ruby，接着在命令行输入下面的命令： 1gem install sass 然后，就可以使用了。 2.2 使用 SASS文件就是普通的文本文件，里面可以直接使用CSS语法。文件后缀名是.scss，意思为Sassy CSS。 下面的命令，可以在屏幕上显示.scss文件转化的css代码。（假设文件名为test。） 1sass test.scss 如果要将显示结果保存成文件，后面再跟一个.css文件名。 1sass test.scss test.css SASS提供四个编译风格的选项： 1234* nested：嵌套缩进的css代码，它是默认值。* expanded：没有缩进的、扩展的css代码。* compact：简洁格式的css代码。* compressed：压缩后的css代码。 生产环境当中，一般使用最后一个选项。 1sass --style compressed test.sass test.css 你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。 1234// watch a filesass --watch input.scss:output.css// watch a directorysass --watch app/sass:public/stylesheets 常用命令 1sass --watch sass:css --style compressed 三、基本用法3.1 变量 SASS允许使用变量，所有变量以$开头。 1234$blue : #1875e7; div { color : $blue;} 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。 1234$side : left;.rounded { border-#{$side}-radius: 5px;} 3.2 计算功能 SASS允许在代码中使用算式： 12345body { margin: (14px/2); top: 50px + 100px; right: $var * 10%;} 3.3 嵌套 SASS允许选择器嵌套。比如，下面的CSS代码： 123div h1 { color : red;} 可以写成： 12345div { hi { color:red; }} 属性也可以嵌套，比如border-color属性，可以写成： 12345p { border: { color: red; }} 注意，border后面必须加上冒号。 在嵌套的代码块内，可以使用&amp;引用父元素。比如a:hover伪类，可以写成： 123a { &amp;:hover { color: #ffb3ff; }} 3.4 注释 SASS共有两种注释风格。 标准的CSS注释 /* comment */ ，会保留到编译后的文件。 单行注释 // comment，只保留在SASS源文件中，编译后被省略。 在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。 123/*! 重要注释！*/ 四、代码的重用4.1 继承 SASS允许一个选择器，继承另一个选择器。比如，现有class1： 123.class1 { border: 1px solid #ddd;} class2要继承class1，就要使用@extend命令： 1234.class2 { @extend .class1; font-size:120%;} 4.2 Mixin Mixin有点像C语言的宏（macro），是可以重用的代码块。 使用@mixin命令，定义一个代码块。 1234@mixin left { float: left; margin-left: 10px;} 使用@include命令，调用这个mixin。 123div { @include left;} mixin的强大之处，在于可以指定参数和缺省值。 1234@mixin left($value: 10px) { float: left; margin-right: $value;} 使用的时候，根据需要加入参数： 123div { @include left(20px);} 下面是一个mixin的实例，用来生成浏览器前缀。 12345@mixin rounded($vert, $horz, $radius: 10px) { border-#{$vert}-#{$horz}-radius: $radius; -moz-border-radius-#{$vert}#{$horz}: $radius; -webkit-border-#{$vert}-#{$horz}-radius: $radius;} 使用的时候，可以像下面这样调用： 12#navbar li { @include rounded(top, left); }#footer { @include rounded(top, left, 5px); } 4.3 颜色函数 SASS提供了一些内置的颜色函数，以便生成系列颜色。 1234lighten(#cc3, 10%) // #d6d65cdarken(#cc3, 10%) // #a3a329grayscale(#cc3) // #808080complement(#cc3) // #33c 4.4 插入文件 @import命令，用来插入外部文件。 1@import &quot;path/filename.scss&quot;; 如果插入的是.css文件，则等同于css的import命令。 1@import &quot;foo.css&quot;; 五、高级用法5.1 条件语句 @if可以用来判断： 1234p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 &lt; 3 { border: 2px dotted; }} 配套的还有@else命令： 12345@if lightness($color) &gt; 30% { background-color: #000;} @else { background-color: #fff;} 5.2 循环语句 SASS支持for循环： 12345@for $i from 1 to 10 { .border-#{$i} { border: #{$i}px solid blue; }} 也支持while循环： 12345$i: 6;@while $i &gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2;} each命令，作用与for类似： 12345@each $member in a, b, c, d { .#{$member} { background-image: url(&quot;/image/#{$member}.jpg&quot;); }} 5.3 自定义函数 SASS允许用户编写自己的函数。 123456@function double($n) { @return $n * 2;}#sidebar { width: double(5px);}","link":"/2016/08/16/css-sass/"},{"title":"禁止复制、选中文本","text":"123456Element { -webkit-user-select: none; -moz-user-select: none; -khtml-user-select: none; user-select: none;}","link":"/2016/03/25/css-user-select/"},{"title":"单行内图片和文字垂直居中(vertical-align:middle)","text":"当图片和文字在div内单行排列时，文字会自动与图片的底部对齐，如果我们要使图片和文字垂直居中，只需要在图片img属性里加上vertical-align:middle;就可以了。 1img { vertical-align:middle;}","link":"/2016/03/24/css-vertical-align/"},{"title":"git cheatsheet 中文速查表 (2019&#x2F;09&#x2F;16)","text":"配置12git config --global &quot;Your Name&quot;git config --global &quot;Email Address&quot; 初始化1git init 提交修改12345git add &lt;file&gt;git add -u 提交work directory中所有已track的文件至staging areagit commit -m &quot;descriptions&quot;git commit --amend 对最近一次的提交做内容修改git commit --amend --author &quot;user_name &lt;user_email&gt;&quot; 修改最近提交用户名和邮箱 查看状态、比对123456git statusgit status -s 文件状态缩略信息, 常见 A:新增; M:文件变更; ?:未track; D:删除git diff &lt;file&gt;git diff HEAD -- &lt;file&gt; 查看工作区和版本库里面最新版本的区别git diff --check &lt;file&gt; 检查是否有空白错误(regex:' \\{1,\\}$')git diff --cached &lt;file&gt; 查看已add的内容(绿M) 查看历史版本、历史操作1234567891011121314151617181920212223242526git loggit refloggit log -n 最近n条的提交历史git log &lt;branch_name&gt; -n 分支branch_name最近n条的提交历史git log --stat 历次commit的文件变化git log lhs_hash..rhs_hash 对比两次commit的变化(增删的主语为lhs, 如git log HEAD~2..HEAD == git log HEAD -3)git log -p 历次commit的内容增删git log -p -W 历次commit的内容增删, 同时显示变更内容的上下文git log origin/EI-1024 -1 --stat -p -W 查看远端分支EI-1024前一次修改的详细内容git log origin/master..dev --stat -p -W 查看本地dev分支比远端master分支变化(修改)的详细内容git log &lt;branch_name&gt; --oneline 对提交历史单行排列git log &lt;branch_name&gt; --graph 对提交历史图形化排列git log &lt;branch_name&gt; --decorate 对提交历史关联相关引用, 如tag, 本地远程分支等git log &lt;branch_name&gt; --oneline --graph --decorate 拼接一下, 树形化显示历史git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen%ai(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit 同上, 建议alais保存git log --since --after 显示时间之后的提交git log --until --before 显示时间之前的提交git log --author 显示指定作者的提交git log --committer 显示指定committer的提交(注:committer不一定是author)git log origin/b3.3/master --author=yx-ren --since=&quot;2019-10-01&quot; --before=&quot;2019-11-01&quot; 查看某作者在某发布版本最近一个月的提交, 常见于线上背锅git log origin/b3.0/master --author=some_leave --since=&quot;1 month ago&quot; 查看某刚离职同事过去一个月的提交, 常见于背锅git log --since=1.weeks 过去一周的提交(写周报的时候可以看看我这一周干了啥)git log --since=1.days 过去一天的提交(下班的时候可以看看我这一天干了啥)git log --since=&quot;1 weeks 2 days 3 hours 40 minutes 50 seconds ago&quot; 过去1周2天3小时40分50秒之内的提交 版本回退、前进123git reset --hard HEAD^ 回退到上1版本git reset --hard HEAD~5 回退到上5个版本git reset --hard id 回退到指定版本 撤销修改1234git checkout -- &lt;file&gt; 撤销修改：误修改工作区文件，未git add/commitgit restore &lt;file&gt; 撤销修改：误修改工作区文件，未git add/commitgit reset HEAD &lt;file&gt; 撤销git add：误将文件加入暂存区（git add），未git commitgit reset --hard HEAD^ 撤销git commit：误将文件提交（一旦提交，只能通过版本回退进行撤销） 删除与恢复123git rm/add &lt;file&gt;git commit -m &quot;remove &lt;file&gt;&quot; 删除版本库中的&lt;file&gt;：删除工作区文件后，继续删除版本库中相应的文件git checkout -- &lt;file&gt; 根据版本库中的&lt;file&gt;恢复工作区&lt;file&gt; 关联GitHub远程仓库（本地到远程）1234567git remote add origin &lt;remote address&gt; 在本地工作区目录下按照 GitHub 提示进行关联git remote rm origin 解除错误关联git push -u origin master 第一次将本地仓库推送至远程仓库（每次在本地提交后进行操作）git push origin master 以后每次将本地仓库推送至远程仓库（每次在本地提交后进行操作）&lt;remote address&gt;: git@github.com:&lt;username&gt;/&lt;repository&gt;.git https://github.com/&lt;username&gt;/&lt;repository&gt;.git 克隆GitHub远程仓库（远程到本地）1git clone &lt;remote address&gt; git协议速度更快但通常公司内网不允许，https协议速度慢 分支管理：创建、切换、查看、合并、删除12345678git branch &lt;branch name&gt; 创建&lt;branch name&gt;分支git checkout &lt;branch name&gt; 切换至&lt;branch name&gt;分支git switch &lt;branch name&gt; 切换至&lt;branch name&gt;分支git checkout -b &lt;branch name&gt; 创建并切换至&lt;branch name&gt;分支git switch -c &lt;branch name&gt; 创建并切换至&lt;branch name&gt;分支git branch 查看已有分支（* 表示当前分支）git merge &lt;branch name&gt; 合并&lt;branch name&gt;到当前分支（通常在master分支下操作）git branch -d &lt;branch name&gt; 删除分支 解决合并冲突123合并时报错“分支发生冲突”，首先vim相应文件，修改冲突位置，然后按照git add/commit重新提交，最后删除多余分支即可。git log --graph --pretty=oneline --abbrev-commitgit log --graph 分支管理：合并后删除分支也在 log 中保留分支记录1git merge --no-ff -m &quot;descriptions&quot; &lt;branch name&gt; 开发流程：123master分支 发布稳定版本dev分支 发布开发版本&lt;developer name&gt;分支 个人开发分支（个人开发完成将该分支并入dev，同时保留该分支，继续开发） Bug分支管理（建立单独分支进行bug修复）1234567软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。git stash 保存当前工作现场（在dev未完成开发，但master有bug需要修复）git stash pop 回到dev分支后恢复工作现场（list中的现场会同时被删除）git stash list 查看当前存储的工作现场git stash apply stash@{#} 回到指定工作现场（list中的现场不会被删除，需要用git stash drop）git stash drop stash@{#} 删除指定工作现场git cherry-pick &lt;id&gt; 在master修复好bug后，在dev复制一遍bug修复流程 Feature分支管理（建立单独分支添加新功能）12软件开发中，总有无穷无尽的新的功能要不断添加进来。添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。git branch -D &lt;branch name&gt; 强制删除分支（丢弃未合并分支） 协作与分支推送12345678910111213User 1:git remote [-v] 查看远程库信息（-v 查看详细信息）git push origin [master/dev/...] 推送指定分支到远程User 2:git clone &lt;remote address&gt; 克隆到本地（只能克隆master）git checkout -b dev origin/dev 本地新建分支并关联远程git add/commit/push 添加、提交、推送更新User 1:git add/commit/push 推送时报错（与user 2推送的更新冲突）git pull &lt;remote&gt; &lt;branch&gt;git branch --set-upstream-to=origin/&lt;branch&gt; &lt;branch&gt; 本地与远程关联git pull 拉取远程文件（并解决冲突）git commit/push 重新提交并推送 标签管理（常用于版本管理）：查看、创建、操作12345678910git tag 查看标签git show &lt;tag name&gt; 查看指定标签git log --pretty=oneline --abbrev-commit --decorate=full 在log中显示标签git tag &lt;tag name&gt; 为上次commit位置打标签git tag &lt;tag name&gt; &lt;commit id&gt; 为指定commit位置打标签git tag -a &lt;tag name&gt; -m &quot;descriptions&quot; &lt;commit id&gt; 为指定commit打标并添加描述git tag -d &lt;tag name&gt; 删除本地标签git push origin &lt;tag name&gt; 推送指定标签到远程git push origin --tags 推送所有本地标签到远程git push origin :refs/tags/&lt;tag name&gt; 删除远程标签（先删除本地标签） rebase(换基)12345# rebase 在日常中常用功能主要是两个, 多人协同开发定期rebase master以及压缩某分支多个commitgit rebase master 常见于多人开发, 每个开发人员从master checkout出自己的分支, 开发一段时间后提交至master之前最好rebase一下, 防止冲突,就算真有冲突在本地解决好过强制提交, 开发流程中尽量保证master的干净整洁git rebase -i HEAD~n 压缩当前分支的n个commit并合并为1个commit, 常见第一行为pick, 剩下的n-1行为squashgit rebase --abort # rebase过程中发生错误, 可以利用该命令终止整个rebase过程git rebase --continue # rebase过程中发生冲突, 在解决冲突后可以利用该命令进行后续过程 打patch(补丁)1234567891011121314151617181920212223# 生成diff patch文件(git可以识别diff文件)git &lt;branch&gt; log -n -p &gt; diff.patch # 生成某分支过去n个commit的文件diff信息至单个diff文件git diff &lt;--cached&gt; diff.patch # 针对当前缓存区的内容生成diff文件# 利用apply打patchgit apply --check diff.patch #检查是否可以正常应用, 无回显证明无冲突git apply --stat diff.patch #查看应用diff文件后的文件变化git apply diff.patch #打patch, 仅仅改变文件信息, 无commit信息, 仍然需要add, commit# 利用--format-patch生成patch, 带commit信息git format-patch &lt;branch&gt; -n #生成分支&lt;branch&gt;最近的n次commit的patchgit format-patch &lt;r1&gt;..&lt;r2&gt; #生成两个commit间的修改的patch（包含两个commit. &lt;r1&gt;和&lt;r2&gt;都是具体的commit号)git format-patch -1 &lt;r1&gt; #生成单个commit的patchgit format-patch &lt;r1&gt; #生成某commit以来的修改patch（不包含该commit）git format-patch --root &lt;r1&gt; #生成从根到r1提交的所有patch# 利用am打patchgit apply --check 0001-update-bash.sh.patch #检查patch是否冲突可用git apply --stat 0001-update-bash.sh.patch #检查patch文件变更情况, 无回显证明无冲突git am 0001-update-bash.sh.patch #将该patch打上到当前分支, 带commit信息git am ./*.patch #将当前路径下的所有patch按照先后顺序打上git am --abort #终止整个打patch的过程, 类似rebase --abortgit am --resolved #解决冲突后, 可以执行该命令进行后续的patch, 类似rebase --continue 使用GitHub1fork --&gt; clone --&gt; add/commit/push --&gt; pull request 其他配置1git config --global color.ui true 显示颜色 配置.gitignore文件123/&lt;dir name&gt;/ 忽略文件夹*.zip 忽略.zip文件/&lt;dir name&gt;/&lt;file name&gt; 忽略指定文件 文件.gitignore生效后12git add -f &lt;file&gt; 强制添加git check-ignore -v &lt;file&gt; 查看生效规则 配置别名123git config [--global] alias.&lt;alias&gt; '&lt;original command&gt;' 为所有工作区/当前工作区配置别名.git/config 当前工作区的配置文件~/.gitconfig 当前用户的配置文件","link":"/2020/05/25/git-cheatsheet/"},{"title":"git shallow clone","text":"git clone 默认会下载项目的完整历史版本，如果你只关心最新版的代码，而不关心之前的历史信息，可以使用 git 的浅复制功能： 1$ git clone --depth=1 git@github.com:hd1987/hd1987.github.io.git --depth=1 表示只下载最近一次的版本，使用浅复制可以大大减少下载的数据量，如果之后又想获取完整历史信息，可以使用下面的命令： 1$ git fetch --unshallow","link":"/2018/06/04/git-clone-shallow/"},{"title":"Git飞行规则(Flight Rules)","text":"编辑提交(editting commits)我刚才提交了什么?如果你用 git commit -a 提交了一次变化(changes)，而你又不确定到底这次提交了哪些内容。 你就可以用下面的命令显示当前HEAD上的最近一次的提交(commit): 1(main)$ git show 或者 1$ git log -n1 -p 我的提交信息(commit message)写错了如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message): 1$ git commit --amend --only 这会打开你的默认编辑器, 在这里你可以编辑信息. 另一方面, 你也可以用一条命令一次完成: 1$ git commit --amend --only -m 'xxxxxxx' 如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做。 我提交(commit)里的用户名和邮箱不对如果这只是单个提交(commit)，修改它： 1$ git commit --amend --author &quot;New Authorname &lt;authoremail@mydomain.com&gt;&quot; 如果你需要修改所有历史, 参考 ‘git filter-branch’的指南页. 我想从一个提交(commit)里移除一个文件通过下面的方法，从一个提交(commit)里移除一个文件: 123$ git checkout HEAD^ myfile$ git add -A$ git commit --amend 这将非常有用，当你有一个开放的补丁(open patch)，你往上面提交了一个不必要的文件，你需要强推(force push)去更新这个远程补丁。 我想删除我的的最后一次提交(commit)如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。 12$ git reset HEAD^ --hard$ git push -f [remote] [branch] 如果你还没有推到远程, 把Git重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化): 12(my-branch*)$ git reset --soft HEAD@{1} 这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 git revert SHAofBadCommit， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)； 或者, 如果你推的这个分支是rebase-safe的 (例如： 其它开发者不会从这个分支拉), 只需要使用 git push -f； 更多, 请参考 the above section。 删除任意提交(commit)同样的警告：不到万不得已的时候不要这么做. 12$ git rebase --onto SHA1_OF_BAD_COMMIT^ SHA1_OF_BAD_COMMIT$ git push -f [remote] [branch] 或者做一个 交互式rebase 删除那些你想要删除的提交(commit)里所对应的行。 我尝试推一个修正后的提交(amended commit)到远程，但是报错：1234567To https://github.com/yourusername/repo.git! [rejected] mybranch -&gt; mybranch (non-fast-forward)error: failed to push some refs to 'https://github.com/tanay1337/webmaker.org.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 注意, rebasing(见下面)和修正(amending)会用一个新的提交(commit)代替旧的, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (-f)。 注意 &amp;ndash; 总是 确保你指明一个分支! 1(my-branch)$ git push origin mybranch -f 一般来说, 要避免强推. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。 我意外的做了一次硬重置(hard reset)，我想找回我的内容如果你意外的做了 git reset --hard, 你通常能找回你的提交(commit), 因为Git对每件事都会有日志，且都会保存几天。 1(main)$ git reflog 你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。 选择你想要回到的提交(commit)的SHA，再重置一次: 1(main)$ git reset --hard SHA1234 这样就完成了。 暂存(Staging)我需要把暂存的内容添加到上一次的提交(commit)12(my-branch*)$ git commit --amend 我想要暂存一个新文件的一部分，而不是这个文件的全部一般来说, 如果你想暂存一个文件的一部分, 你可这样做: 1$ git add --patch filename.x -p 简写。这会打开交互模式， 你将能够用 s 选项来分隔提交(commit)； 然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时, 这样做: 1$ git add -N filename.x 然后, 你需要用 e 选项来手动选择需要添加的行，执行 git diff --cached 将会显示哪些行暂存了哪些行只是保存在本地了。 我想把在一个文件里的变化(changes)加到两个提交(commit)里git add 会把整个文件加入到一个提交. git add -p 允许交互式的选择你想要提交的部分. 我想把暂存的内容变成未暂存，把未暂存的内容暂存起来多数情况下，你应该将所有的内容变为未暂存，然后再选择你想要的内容进行commit。但假定你就是想要这么做，这里你可以创建一个临时的commit来保存你已暂存的内容，然后暂存你的未暂存的内容并进行stash。然后reset最后一个commit将原本暂存的内容变为未暂存，最后stash pop回来。 12345$ git commit -m &quot;WIP&quot;$ git add .$ git stash$ git reset HEAD^$ git stash pop --index 0 注意1: 这里使用pop仅仅是因为想尽可能保持幂等。注意2: 假如你不加上--index你会把暂存的文件标记为为存储.这个链接 解释得比较清楚。（不过是英文的，其大意是说，这是一个较为底层的问题，stash时会做2个commit，其中一个会记录index状态，staged的文件等东西，另一个记录worktree和其他的一些东西，如果你不在apply时加index，git会把两个一起销毁，所以staged里就空了）。 未暂存(Unstaged)的内容我想把未暂存的内容移动到一个新分支1$ git checkout -b my-branch 我想把未暂存的内容移动到另一个已存在的分支123$ git stash$ git checkout my-branch$ git stash pop 我想丢弃本地未提交的变化(uncommitted changes)如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以： 12345678# one commit(my-branch)$ git reset --hard HEAD^# two commits(my-branch)$ git reset --hard HEAD^^# four commits(my-branch)$ git reset --hard HEAD~4# or(main)$ git checkout -f 重置某个特殊的文件, 你可以用文件名做为参数: 1$ git reset filename 我想丢弃某些未暂存的内容如果你想丢弃工作拷贝中的一部分内容，而不是全部。 签出(checkout)不需要的内容，保留需要的。 12$ git checkout -p# Answer y to all of the snippets you want to drop 另外一个方法是使用 stash， Stash所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。 1234$ git stash -p# Select all of the snippets you want to save$ git reset --hard$ git stash pop 或者, stash 你不需要的部分, 然后stash drop。 123$ git stash -p# Select all of the snippets you don't want to save$ git stash drop 分支(Branches)我从错误的分支拉取了内容，或把内容拉取到了错误的分支这是另外一种使用 git reflog 情况，找到在这次错误拉(pull) 之前HEAD的指向。 123(main)$ git reflogab7555f HEAD@{0}: pull origin wrong-branch: Fast-forwardc5bc55a HEAD@{1}: checkout: checkout message goes here 重置分支到你所需的提交(desired commit): 1$ git reset --hard c5bc55a 完成。 我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致先确认你没有推(push)你的内容到远程。 git status 会显示你领先(ahead)源(origin)多少个提交: 12345(my-branch)$ git status# On branch my-branch# Your branch is ahead of 'origin/my-branch' by 2 commits.# (use &quot;git push&quot; to publish your local commits)# 一种方法是: 1(main)$ git reset --hard origin/my-branch 我需要提交到一个新分支，但错误的提交到了main在main下创建一个新分支，不切换到新分支,仍在main下: 1(main)$ git branch my-branch 把main分支重置到前一个提交: 1(main)$ git reset --hard HEAD^ HEAD^ 是 HEAD^1 的简写，你可以通过指定要设置的HEAD来进一步重置。 或者, 如果你不想使用 HEAD^, 找到你想重置到的提交(commit)的hash(git log 能够完成)， 然后重置到这个hash。 使用git push 同步内容到远程。 例如, main分支想重置到的提交的hash为a13b85e: 12(main)$ git reset --hard a13b85eHEAD is now at a13b85e 签出(checkout)刚才新建的分支继续工作: 1(main)$ git checkout my-branch 我想保留来自另外一个ref-ish的整个文件假设你正在做一个原型方案(原文为working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容: 1(solution)$ git add -A &amp;&amp; git commit -m &quot;Adding all changes from this spike into one big commit.&quot; 当你想要把它放到一个分支里 (可能是feature, 或者 develop), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。 假设你有: 分支 solution, 拥有原型方案， 领先 develop 分支。 分支 develop, 在这里你应用原型方案的一些内容。 我去可以通过把内容拿到你的分支里，来解决这个问题: 1(develop)$ git checkout solution -- file1.txt 这会把这个文件内容从分支 solution 拿到分支 develop 里来: 123456# On branch develop# Your branch is up-to-date with 'origin/develop'.# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## modified: file1.txt 然后, 正常提交。 Note: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem. ~ Wikipedia. 我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里假设你有一个main分支， 执行git log, 你看到你做过两次提交: 12345678910111213141516171819(main)$ git logcommit e3851e817c451cc36f2e6f3049db528415e3c114Author: Alex Lee &lt;alexlee@example.com&gt;Date: Tue Jul 22 15:39:27 2014 -0400 Bug #21 - Added CSRF protectioncommit 5ea51731d150f7ddc4a365437931cd8be3bf3131Author: Alex Lee &lt;alexlee@example.com&gt;Date: Tue Jul 22 15:39:12 2014 -0400 Bug #14 - Fixed spacing on titlecommit a13b85e984171c6e2a1729bb061994525f626d14Author: Aki Rose &lt;akirose@example.com&gt;Date: Tue Jul 21 01:12:48 2014 -0400 First commit 让我们用提交hash(commit hash)标记bug (e3851e8 for #21, 5ea5173 for #14). 首先, 我们把main分支重置到正确的提交(a13b85e): 12(main)$ git reset --hard a13b85eHEAD is now at a13b85e 现在, 我们对 bug #21 创建一个新的分支: 12(main)$ git checkout -b 21(21)$ 接着, 我们用 cherry-pick 把对bug #21的提交放入当前分支。 这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在HEAD上面。 1(21)$ git cherry-pick e3851e8 这时候, 这里可能会产生冲突， 参见交互式 rebasing 章 冲突节 解决冲突. 再者， 我们为bug #14 创建一个新的分支, 也基于main分支 123(21)$ git checkout main(main)$ git checkout -b 14(14)$ 最后, 为 bug #14 执行 cherry-pick: 1(14)$ git cherry-pick 5ea5173 我想删除上游(upstream)分支被删除了的本地分支一旦你在github 上面合并(merge)了一个pull request, 你就可以删除你fork里被合并的分支。 如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中。 1$ git fetch -p 我不小心删除了我的分支如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。 让我们先创建一个分支和一个新的文件: 12345(main)$ git checkout -b my-branch(my-branch)$ git branch(my-branch)$ touch foo.txt(my-branch)$ lsREADME.md foo.txt 添加文件并做一次提交 123456789101112131415161718(my-branch)$ git add .(my-branch)$ git commit -m 'foo.txt added'(my-branch)$ foo.txt added 1 files changed, 1 insertions(+) create mode 100644 foo.txt(my-branch)$ git logcommit 4e3cd85a670ced7cc17a2b5d8d3d809ac88d5012Author: siemiatj &lt;siemiatj@example.com&gt;Date: Wed Jul 30 00:34:10 2014 +0200 foo.txt addedcommit 69204cdf0acbab201619d95ad8295928e7f411d5Author: Kate Hudson &lt;katehudson@example.com&gt;Date: Tue Jul 29 13:14:46 2014 -0400 Fixes #6: Force pushing after amending commits 现在我们切回到主(main)分支，‘不小心的’删除my-branch分支 1234567(my-branch)$ git checkout mainSwitched to branch 'main'Your branch is up-to-date with 'origin/main'.(main)$ git branch -D my-branchDeleted branch my-branch (was 4e3cd85).(main)$ echo oh noes, deleted my branch!oh noes, deleted my branch! 在这时候你应该想起了reflog, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。 1234(main)$ git reflog69204cd HEAD@{0}: checkout: moving from my-branch to main4e3cd85 HEAD@{1}: commit: foo.txt added69204cd HEAD@{2}: checkout: moving from main to my-branch 正如你所见，我们有一个来自删除分支的提交hash(commit hash)，接下来看看是否能恢复删除了的分支。 123456(main)$ git checkout -b my-branch-helpSwitched to a new branch 'my-branch-help'(my-branch-help)$ git reset --hard 4e3cd85HEAD is now at 4e3cd85 foo.txt added(my-branch-help)$ lsREADME.md foo.txt 看! 我们把删除的文件找回来了。 Git的 reflog 在rebasing出错的时候也是同样有用的。 我想删除一个分支删除一个远程分支: 1(main)$ git push origin --delete my-branch 你也可以: 1(main)$ git push origin :my-branch 删除一个本地分支: 1(main)$ git branch -D my-branch 我想从别人正在工作的远程分支签出(checkout)一个分支首先, 从远程拉取(fetch) 所有分支: 1(main)$ git fetch --all 假设你想要从远程的daves分支签出到本地的daves 123(main)$ git checkout --track origin/davesBranch daves set up to track remote branch daves from origin.Switched to a new branch 'daves' (--track 是 git checkout -b [branch] [remotename]/[branch] 的简写) 这样就得到了一个daves分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到. Rebasing 和合并(Merging)我想撤销rebase/merge你可以合并(merge)或rebase了一个错误的分支, 或者完成不了一个进行中的rebase/merge。 Git 在进行危险操作的时候会把原始的HEAD保存在一个叫ORIG_HEAD的变量里, 所以要把分支恢复到rebase/merge前的状态是很容易的。 1(my-branch)$ git reset --hard ORIG_HEAD 我已经rebase过, 但是我不想强推(force push)不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。 是因你快进(Fast forward)了提交，改变了Git历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做: 1234(main)$ git checkout my-branch(my-branch)$ git rebase -i main(my-branch)$ git checkout main(main)$ git merge --ff-only my-branch 更多, 参见 this SO thread. 我需要组合(combine)几个提交(commit)假设你的工作分支将会做对于 main 的pull-request。 一般情况下你不关心提交(commit)的时间戳，只想组合 所有 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。 确保主(main)分支是最新的和你的变化都已经提交了, 然后: 12(my-branch)$ git reset --soft main(my-branch)$ git commit -am &quot;New awesome feature&quot; 如果你想要更多的控制, 想要保留时间戳, 你需要做交互式rebase (interactive rebase): 1(my-branch)$ git rebase -i main 如果没有相对的其它分支， 你将不得不相对自己的HEAD 进行 rebase。 例如：你想组合最近的两次提交(commit), 你将相对于HEAD~2 进行rebase， 组合最近3次提交(commit), 相对于HEAD~3, 等等。 1(main)$ git rebase -i HEAD~2 在你执行了交互式 rebase的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容: 12345678910111213141516171819202122pick a9c8a1d Some refactoringpick 01b2fd8 New awesome featurepick b729ad5 fixuppick e3851e8 another fix# Rebase 8074d12..b729ad5 onto 8074d12## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit's log message# x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 所有以 # 开头的行都是注释, 不会影响 rebase. 然后，你可以用任何上面命令列表的命令替换 pick, 你也可以通过删除对应的行来删除一个提交(commit)。 例如, 如果你想 单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 f: 1234pick a9c8a1d Some refactoringpick 01b2fd8 New awesome featuref b729ad5 fixupf e3851e8 another fix 如果你想组合这些提交(commit) 并重命名这个提交(commit), 你应该在第二个提交(commit)旁边添加一个r，或者更简单的用s 替代 f: 1234pick a9c8a1d Some refactoringpick 01b2fd8 New awesome features b729ad5 fixups e3851e8 another fix 你可以在接下来弹出的文本提示框里重命名提交(commit)。 1234567891011Newer, awesomer features# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.# rebase in progress; onto 8074d12# You are currently editing a commit while rebasing branch 'main' on '8074d12'.## Changes to be committed:# modified: README.md# 如果成功了, 你应该看到类似下面的内容: 1(main)$ Successfully rebased and updated refs/heads/main. 安全合并(merging)策略--no-commit 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。 no-ff 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致。 1(main)$ git merge --no-ff --no-commit my-branch 我需要将一个分支合并成一个提交(commit)1(main)$ git merge --squash my-branch 我只想组合(combine)未推的提交(unpushed commit)有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。 1(main)$ git rebase -i @{u} 这会产生一次交互式的rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行reorder/fix/squash 都是安全的。 检查是否分支上的所有提交(commit)都合并(merge)过了检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的head(或任何 commits)之间做一次diff: 1(main)$ git log --graph --left-right --cherry-pick --oneline HEAD...feature/120-on-scroll 这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。 另一个做法可以是: 1(main)$ git log main ^feature/120-on-scroll --no-merges 交互式rebase(interactive rebase)可能出现的问题这个rebase 编辑屏幕出现’noop’如果你看到的是这样: 1noop 这意味着你rebase的分支和当前分支在同一个提交(commit)上, 或者 领先(ahead) 当前分支。 你可以尝试: 检查确保主(main)分支没有问题 rebase HEAD~2 或者更早 有冲突的情况如果你不能成功的完成rebase, 你可能必须要解决冲突。 首先执行 git status 找出哪些文件有冲突: 1234567(my-branch)$ git statusOn branch my-branchChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: README.md 在这个例子里面, README.md 有冲突。 打开这个文件找到类似下面的内容: 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADsome code=========some code&gt;&gt;&gt;&gt;&gt;&gt;&gt; new-commit 你需要解决新提交的代码(示例里, 从中间==线到new-commit的地方)与HEAD 之间不一样的地方. 有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor): 1(main*)$ git mergetool -t opendiff 在你解决完所有冲突和测试过后, git add 变化了的(changed)文件, 然后用git rebase --continue 继续rebase。 12(my-branch)$ git add README.md(my-branch)$ git rebase --continue 如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行git rebase --skip。 任何时候你想结束整个rebase 过程，回来rebase前的分支状态, 你可以做: 1(my-branch)$ git rebase --abort Stash暂存所有改动暂存你工作目录下的所有改动 1$ git stash 你可以使用-u来排除一些文件 1$ git stash -u 暂存指定文件假设你只想暂存某一个文件 1$ git stash push working-directory-path/filename.ext 假设你想暂存多个文件 1$ git stash push working-directory-path/filename1.ext working-directory-path/filename2.ext 暂存时记录消息这样你可以在list时看到它 1$ git stash save &lt;message&gt; 或 1$ git stash push -m &lt;message&gt; 使用某个指定暂存首先你可以查看你的stash记录 1$ git stash list 然后你可以apply某个stash 1$ git stash apply &quot;stash@{n}&quot; 此处， ‘n’是stash在栈中的位置，最上层的stash会是0 除此之外，也可以使用时间标记(假如你能记得的话)。 1$ git stash apply &quot;stash@{2.hours.ago}&quot; 暂存时保留未暂存的内容你需要手动create一个stash commit， 然后使用git stash store。 12$ git stash create$ git stash store -m &quot;commit-message&quot; CREATED_SHA1 杂项(Miscellaneous Objects)克隆所有子模块1$ git clone --recursive git://github.com/foo/bar.git 如果已经克隆了: 1$ git submodule update --init --recursive 删除标签(tag)12$ git tag -d &lt;tag_name&gt;$ git push &lt;remote&gt; :refs/tags/&lt;tag_name&gt; 恢复已删除标签(tag)如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag): 1$ git fsck --unreachable | grep tag 记下这个标签(tag)的hash，然后用Git的 update-ref: 1$ git update-ref refs/tags/&lt;tag_name&gt; &lt;hash&gt; 这时你的标签(tag)应该已经恢复了。 已删除补丁(patch)如果某人在 GitHub 上给你发了一个pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 git am。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。 做完提交后, 再修改作者，参见变更作者。 然后, 应用变化, 再发起一个新的pull request。 跟踪文件(Tracking Files)我只想改变一个文件名字的大小写，而不修改内容1(main)$ git mv --force myfile MyFile 我想从Git删除一个文件，但保留该文件1(main)$ git rm --cached log.txt 配置(Configuration)我想给一些Git命令添加别名(alias)在 OS X 和 Linux 下, 你的 Git的配置文件储存在 ~/.gitconfig。我在[alias] 部分添加了一些快捷别名(和一些我容易拼写错误的)，如下: 1234567891011121314151617181920[alias] a = add amend = commit --amend c = commit ca = commit --amend ci = commit -a co = checkout d = diff dc = diff --changed ds = diff --staged f = fetch loll = log --graph --decorate --pretty=oneline --abbrev-commit m = merge one = log --pretty=oneline outstanding = rebase -i @{u} s = status unpushed = log @{u} wc = whatchanged wip = rebase -i @{u} zap = fetch -p 我想缓存一个仓库(repository)的用户名和密码你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推/拉(push/pull)的时候都输入，Credential helper能帮你。 12$ git config --global credential.helper cache# Set git to use the credential memory cache 12$ git config --global credential.helper 'cache --timeout=3600'# Set the cache to timeout after 1 hour (setting is in seconds) 我不知道我做错了些什么你把事情搞砸了：你 重置(reset) 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。 这就是 git reflog 的目的， reflog 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次HEAD的改变, 一条新的记录就会增加到reflog。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。 1234(main)$ git reflog0a2e358 HEAD@{0}: reset: moving to HEAD~20254ea7 HEAD@{1}: checkout: moving from 2.2 to mainc10f740 HEAD@{2}: checkout: moving from main to 2.2 上面的reflog展示了从main分支签出(checkout)到2.2 分支，然后再签回。 那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 HEAD@{0}标识. 如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前main上指向的提交(0254ea7)。 1$ git reset --hard 0254ea7 然后使用git reset就可以把main改回到之前的commit，这提供了一个在历史被意外更改情况下的安全网。","link":"/2021/01/19/git-flight-rules/"},{"title":"Git 忽略文件不加入版本控制","text":".gitignore1234567# 此为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txttmp/* # 忽略tmp文件夹所有文件，因为git不会加入空目录 其它过滤条件 ？ : 代表任意的一个字符 ＊ : 代表任意数目的字符 {!ab} : 必须不是此类型 {ab,bb,cx} : 代表ab,bb,cx中任一类型即可 [abc] : 代表a,b,c中任一字符即可 [ ^abc] : 代表必须不是a,b,c中任一字符 .gitignoreglobal在用户目录下创建 ~/.gitignoreglobal 文件,需要执行 git config --global core.excludesfile ~/.gitignoreglobal 来使得它生效。 忽略本地的文件控制，不影响全局.git/info/exclude 这里设置的是你自己本地需要排除的文件，他不会影响到其他人，也不会提交到版本库中去。 去除已经提交文件的版本控制（公共） rm -rf PATH git rm -r --cached PATH 修改.gitignore，添加忽略文件 git add -A git push 忽略已经提交到版本库的文件（本地）git update-index --assume-unchanged PATH # 忽略跟踪git update-index --no-assume-unchanged PATH #恢复跟踪 提交空的目录树需要提交一个空的 log 目录时，在里面放置一个空的.gitignore","link":"/2018/05/28/git-ignore/"},{"title":"Git使用摘要","text":"Git是一个“分布式版本管理工具”，简单的理解版本管理工具：大家在写东西的时候都用过“回撤”这个功能，但是回撤只能回撤几步，假如想要找回我三天之前的修改，光用“回撤”是找不回来的。而“版本管理工具”能记录每次的修改，只要提交到版本仓库，你就可以找到之前任何时刻的状态（文本状态）。 下面的内容就是列举了常用的Git命令和一些小技巧，可以通过”页面内查找”的方式进行快速查询：Ctrl/Command+f。 开卷必读 所有的命令都在git version 2.7.4 (Apple Git-66)下测试通过 统一概念： 工作区：改动（增删文件和内容） 暂存区：输入命令：git add 改动的文件名，此次改动就放到了‘暂存区’ 本地仓库(简称：本地)：输入命令：git commit 此次修改的描述，此次改动就放到了’本地仓库’，每个commit，我叫它为一个‘版本’。 远程仓库(简称：远程)：输入命令：git push 远程仓库，此次改动就放到了‘远程仓库’（GitHub等) commit-id：输出命令：git log，最上面那行commit xxxxxx，后面的字符串就是commit-id 展示帮助信息1git help -g 回到远程仓库的状态抛弃本地所有的修改，回到远程仓库的状态。 1git fetch --all &amp;&amp; git reset --hard origin/master 更新远程分支1git fetch --all --prune 重设第一个commit也就是把所有的改动都重新放回工作区，并清空所有的commit，这样就可以重新提交第一个commit了 1git update-ref -d HEAD 展示工作区和暂存区的不同输出工作区和暂存区的different(不同)。 1git diff 还可以展示本地仓库中任意两个commit之间的文件变动： 1git diff &lt;commit-id&gt; &lt;commit-id&gt; 展示暂存区和最近版本的不同输出暂存区和本地最近的版本(commit)的different(不同)。 1git diff --cached 展示暂存区、工作区和最近版本的不同输出工作区、暂存区 和本地最近的版本(commit)的different(不同)。 1git diff HEAD 删除已经合并到master的分支1git branch --merged master | grep -v '^\\*\\| master' | xargs -n 1 git branch -d 展示本地分支关联远程仓库的情况1git branch -vv 关联远程分支关联之后，git branch -vv就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。 1git branch -u origin/mybranch 或者在push时加上-u参数 1git push origin/mybranch -u 列出所有远程分支-r参数相当于：remote 1git branch -r 列出本地和远程分支-a参数相当于：all 1git branch -a 快速切换分支1git checkout - 创建并切换到本地分支1git checkout -b &lt;branch-name&gt; 创建并切换到远程分支1git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt; 删除本地分支1git branch -d &lt;local-branchname&gt; 删除远程分支1git push origin --delete &lt;remote-branchname&gt; 或者 1git push origin :&lt;remote-branchname&gt; 重命名本地分支1git branch -m &lt;new-branch-name&gt; 查看标签1git tag 展示当前分支的最近的tag 1git describe --tags --abbrev=0 本地创建标签1git tag &lt;version-number&gt; 默认tag是打在最近的一次commit上，如果需要指定commit打tag： 1$ git tag -a &lt;version-number&gt; -m &quot;v1.0 发布(描述)&quot; &lt;commit-id&gt; 推送标签到远程仓库首先要保证本地创建好了标签才可以推送标签到远程仓库： 1git push origin &lt;local-version-number&gt; 一次性推送所有标签，同步到远程仓库： 1git push origin --tags 删除本地标签1git tag -d &lt;tag-name&gt; 删除远程标签删除远程标签需要先删除本地标签，再执行下面的命令： 1git push origin :refs/tags/&lt;tag-name&gt; 切回到某个标签一般上线之前都会打tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态： 1git checkout -b branch_name tag_name 放弃工作区的修改1git checkout &lt;file-name&gt; 放弃所有修改： 1git checkout . 回到某一个commit的状态，并重新增添一个commit1git revert &lt;commit-id&gt; 回到某个commit的状态，并删除后面的commit和revert的区别：reset命令会抹去某个commit id之后的所有commit 1git reset &lt;commit-id&gt; 把暂存区的指定file放到工作区中1git reset &lt;file-name&gt; 重置暂存区，把所有修改放到工作区1git reset --mixed HEAD 重置暂存区和工作区，清除所有修改1git reset --hard HEAD 撤回上一次的提交（保留工作区和暂存区状态）1git reset --soft HEAD^ 添加工作区所有修改并提交1git commit -a -m &quot;message&quot; 修改上一个commit的描述1git commit --amend 修改作者名1git commit --amend --author='Author Name &lt;email@address.com&gt;' 查看commit历史1git log 显示提交详情1git log --stat 显示简短信息1git log --oneline 显示图表线1git log --graph 查看某段代码是谁写的blame的意思为‘责怪’，你懂的。 1git blame &lt;file-name&gt; 显示本地执行过git命令就像shell的history一样 1git reflog 修改远程仓库的url1git remote set-url origin &lt;URL&gt; 增加远程仓库1git remote add origin &lt;remote-url&gt; 列出所有远程仓库1git remote 查看两个星期内的改动1git whatchanged --since='2 weeks ago' 把A分支的某一个commit，放到B分支上这个过程需要cherry-pick命令，参考 1git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt; 给git命令起别名简化命令 12345git config --global alias.&lt;handle&gt; &lt;command&gt;比如：git status 改成 git st，这样可以简化命令git config --global alias.st status 存储当前的修改，但不用提交commit详解可以参考廖雪峰老师的git教程 1git stash 保存当前状态，包括untracked的文件untracked文件：新建的文件 1git stash -u 展示所有stashes1git stash list 回到某个stash的状态1git stash apply &lt;stash@{n}&gt; 回到最后一个stash的状态，并删除这个stash1git stash pop 删除所有的stash1git stash clear 从stash中拿出某个文件的修改1git checkout &lt;stash@{n}&gt; -- &lt;file-path&gt; 查看版本库文件1git ls-files 展示所有tracked的文件1git ls-files -t 展示所有untracked的文件1git ls-files --others 展示所有忽略的文件1git ls-files --others -i --exclude-standard 查看不受版本控制的可以删除的文件1git clean -nd 执行删除不受版本控制的文件1git clean -fd 强制删除untracked的文件可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的untracked文件。clean命令，注意两点： clean后，删除的文件无法找回 不会影响tracked的文件的改动，只会删除untracked的文件 1git clean &lt;file-name&gt; -f 强制删除untracked的目录可以用来删除新建的目录，注意:这个命令也可以用来删除untracked的文件。详情见上一条 1git clean &lt;directory-name&gt; -df 展示简化的commit历史1git log --pretty=oneline --graph --decorate --all 把某一个分支到导出成一个文件1git bundle create &lt;file&gt; &lt;branch-name&gt; 从包中导入分支新建一个分支，分支内容就是上面git bundle create命令导出的内容 1git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt; 变基到develop分支1git rebase origin/develop 执行rebase之前自动stash1git rebase --autostash 从远程仓库根据ID，拉下某一状态，到本地分支1git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt; 从远程仓库拉取最新的提交，合并到同一根线上1git pull --rebase pull –rebase冲突解决后继续执行1git rebase --continue 合并，保留feature， 更好地查看merge历史1git merge --no-ff 详细展示一行中的修改1git diff --word-diff 清除gitignore文件中记录的文件1git clean -X -f 展示所有alias和configs注意： config分为：当前目录（local）和全局（golbal）的config，默认为当前目录的config 12git config --local --list (当前目录)git config --global --list (全局) 展示忽略的文件1git status --ignored 输出精简信息1git status -s commit历史中显示Branch1有的，但是Branch2没有commit1git log Branch1 ^Branch2 在commit log中显示GPG签名1git log --show-signature 删除全局设置1git config --global --unset &lt;entry-name&gt; 新建并切换到新分支上，同时这个分支没有任何commit相当于保存修改，但是重写commit历史 1git checkout --orphan &lt;branch-name&gt; 展示任意分支某一文件的内容1git show &lt;branch-name&gt;:&lt;file-name&gt; clone下来指定的单一分支1git clone -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git 忽略某个文件的改动关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动 1git update-index --assume-unchanged path/to/file 恢复 track 指定文件的改动 1git update-index --no-assume-unchanged path/to/file 忽略文件的权限变化不再将文件的权限变化视作改动 1git config core.fileMode false 展示本地所有的分支的commit最新的放在最上面 1git for-each-ref --sort=-committerdate --format='%(refname:short)' refs/heads/ 在commit log中查找相关内容通过grep查找，given-text：所需要查找的字段 1git log --all --grep='&lt;given-text&gt;' 强制推送1git push -f &lt;remote-name&gt; &lt;branch-name&gt; 查询指针当前位置1cat .git/HEAD 去除文件的版本控制123451. rm -rf 文件2. git rm -r --cached 要忽略的文件3. 修改gitignore，添加忽略文件4. git add -A (添加所有)5. git push origin 分支 ⬆ 返回顶部","link":"/2017/03/21/git-memo/"},{"title":"git 修改本地和远程分支名称","text":"git branch -a #查看所有分支git branch -r #查看远程分支git branch -vv #查看本地分支所关联的远程分支 git branch -m old_branch new_branch #重命名本地分支git push origin :old_branch #删除远程分支git push --set-upstream origin new_branch #推送并关联新的远程分支","link":"/2021/10/20/git-rename-branch/"},{"title":"hexo常用命令笔记","text":"简写hexo n == hexo newhexo p == hexo publishhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署hexo algolia #生成静态网页 (接入algolia后用于生成文件和搜索) 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的hexo generate –deploy hexo deploy –generatehexo deploy -g hexo server -g 草稿hexo publish [layout] &lt;title&gt; 模版hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold）hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 写作hexo new page &lt;title&gt; hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上hexo n #写文章hexo g #生成hexo d #部署 #可与 hexo g 合并为 hexo d -g 报错ERROR Deployer not found: gitnpm install hexo-deployer-git –save","link":"/2016/04/14/hexo-order/"},{"title":"brew常用命令","text":"一般来说如果你追求新版本（不升级不舒服斯基），那么你最常用的操作序列就是这样： 12345brew update # 更新 Homebrew 的信息brew outdated # 看一下哪些软件可以升级brew upgrade &lt;xxx&gt; # 如果不是所有的都要升级，那就这样升级指定的brew upgrade; brew cleanup # 如果都要升级，直接升级完然后清理干净 搜索brew search MySQL 查询brew info mysql 主要看具体的信息，比如目前的版本，依赖，安装后注意事项等 更新brew update 这会更新 Homebrew 自己，并且使得接下来的两个操作有意义 检查过时（是否有新版本）brew outdated 这回列出所有安装的软件里可以升级的那些 升级brew upgrade 升级所有可以升级的软件们 清理brew cleanup 清理不需要的版本极其安装包缓存","link":"/2017/05/24/homebrew/"},{"title":"input text 去掉标签下拉提示(不显示下拉历史)","text":"1&lt;input autocomplete=&quot;off&quot;&gt; 注释：autocomplete 属性适用于 form，以及下面的 input 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。","link":"/2016/03/23/html-autoComplete/"},{"title":"contenteditable 属性规定是否可编辑元素的内容","text":"1&lt;div contenteditable=&quot;true&quot;&gt;这是一段可编辑的段落&lt;/div&gt; 注释：可用于div模拟textarea自适应高度","link":"/2016/03/23/html-contenteditable/"},{"title":"Meta告知IE浏览器兼容模式","text":"x-ua-compatible(浏览器兼容模式)仅对IE8+以效告诉浏览器以什么版本的IE的兼容模式来显示网页 1234&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=5&quot; &gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot; &gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=8&quot; &gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; &gt; 其中最后一行IE=edge是永远以最新的IE版本模式来显示网页的。另外加上Emulate模式 12&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=EmulateIE7&quot; &gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=EmulateIE8&quot; &gt; Emulate模式后则更重视&lt;!DOCTYPE&gt;(细心的人会注意到，用IE9去访问带有x-ua-compatible的页面时是不会出现兼容视图按钮的) 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=EmulateIE8&quot; /&gt;","link":"/2016/03/23/html-meta-equiv/"},{"title":"移动端wap用到的头部信息代码meta","text":"禁止页面缩放1&lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot; name=&quot;viewport&quot; /&gt; 禁止数字拨号功能12&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;&lt;a href=&quot;tel:4008106999,1034&quot;&gt;400-810-6999 转 1034&lt;/a&gt; 全屏模式运行1&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; 顶部状态栏背景色（需全屏运行）1&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt; wap设置缓存1&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot; /&gt; 桌面图标1234&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;touch-icon-iphone.png&quot; /&gt;&lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;76x76&quot; href=&quot;touch-icon-ipad.png&quot; /&gt;&lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;120x120&quot; href=&quot;touch-icon-iphone-retina.png&quot; /&gt;&lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;152x152&quot; href=&quot;touch-icon-ipad-retina.png&quot; /&gt; 启动画面12345678910111213141516171819202122&lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;start.png&quot;/&gt; &lt;!--iPhone--&gt;&lt;link href=&quot;apple-touch-startup-image-320x460.png&quot; media=&quot;(device-width: 320px)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPhone Retina --&gt;&lt;link href=&quot;apple-touch-startup-image-640x920.png&quot; media=&quot;(device-width: 320px) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt;&lt;!-- iPhone 5 --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; media=&quot;(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)&quot; href=&quot;apple-touch-startup-image-640x1096.png&quot;&gt;&lt;!-- iPad portrait --&gt;&lt;link href=&quot;apple-touch-startup-image-768x1004.png&quot; media=&quot;(device-width: 768px) and (orientation: portrait)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt;&lt;!-- iPad landscape --&gt;&lt;link href=&quot;apple-touch-startup-image-748x1024.png&quot; media=&quot;(device-width: 768px) and (orientation: landscape)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt;&lt;!-- iPad Retina portrait --&gt;&lt;link href=&quot;apple-touch-startup-image-1536x2008.png&quot; media=&quot;(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt;&lt;!-- iPad Retina landscape --&gt;&lt;link href=&quot;apple-touch-startup-image-1496x2048.png&quot; media=&quot;(device-width: 1536px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt;","link":"/2016/03/22/html-meta/"},{"title":"jquery实现返回顶部","text":"123456789101112131415//当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失$(function () { $(window).scroll(function(){ if ($(window).scrollTop()&gt;100){ $(&quot;#back-to-top&quot;).fadeIn(1500); } else { $(&quot;#back-to-top&quot;).fadeOut(1500); } }); //当点击跳转链接后，回到页面顶部位置 $(&quot;#back-to-top&quot;).click(function(){ $('body,html').animate({scrollTop:0},1000); return false; });});","link":"/2016/03/25/js-backTop/"},{"title":"当弹出popup悬浮层时，禁止body滚动","text":"示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0&quot; /&gt;&lt;title&gt;test&lt;/title&gt;&lt;style&gt;p { line-height: 110px; }.btn { position: fixed; top: 10px; right: 10px; z-index: 9; padding: 5px 10px; color: #fff; background: #c00; }.mask { position: fixed; top: 0; right: 0; bottom: 0; left: 0; background: rgba(0,0,0,.5); z-index: 99; display: none; }.popup { position: fixed; top: 0; right: 0; bottom: 0; left: 40px; background: #fff; z-index: 101; overflow-y: auto; display: none; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;btn&quot;&gt;Click&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;p&gt;111&lt;/p&gt;&lt;p&gt;222&lt;/p&gt;&lt;p&gt;333&lt;/p&gt;&lt;p&gt;444&lt;/p&gt;&lt;p&gt;555&lt;/p&gt;&lt;p&gt;666&lt;/p&gt;&lt;p&gt;777&lt;/p&gt;&lt;p&gt;888&lt;/p&gt;&lt;p&gt;999&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;div class=&quot;popup&quot;&gt;&lt;p&gt;111&lt;/p&gt;&lt;p&gt;222&lt;/p&gt;&lt;p&gt;333&lt;/p&gt;&lt;p&gt;444&lt;/p&gt;&lt;p&gt;555&lt;/p&gt;&lt;p&gt;666&lt;/p&gt;&lt;p&gt;777&lt;/p&gt;&lt;p&gt;888&lt;/p&gt;&lt;p&gt;999&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt;&lt;/html&gt;&lt;script&gt;var $body = $('body'), scrollTop;$('.btn').on('click', function() { $('.mask, .popup').show(); scrollTop = $body.scrollTop(); //body设置为fixed之后会飘到顶部，所以要动态计算当前用户所在高度 $body.css({ 'overflow':'hidden', 'position': 'fixed', 'top': scrollTop*-1 });});$('.mask').on('click', function() { $('.mask, .popup').hide(); /*取消后设置回来*/ $body.css({ 'overflow':'auto', 'position': 'static', 'top': 'auto' }).animate({ scrollTop: scrollTop }, 0);});&lt;/script&gt;","link":"/2017/01/14/js-body-noscroll/"},{"title":"checkbox 全选 反选","text":"12345678910111213141516171819202122//checkbox全选反选function funCheckbox(){ var intListAll, intListChecked; $(document).on(&quot;click&quot;,&quot;input[name='all']&quot;,function(){ if($(this).is(&quot;:checked&quot;)){ $(&quot;input[name='all']&quot;).prop(&quot;checked&quot;,true); $(&quot;input[name='list']&quot;).prop(&quot;checked&quot;,true); }else { $(&quot;input[name='all']&quot;).prop(&quot;checked&quot;,false); $(&quot;input[name='list']&quot;).prop(&quot;checked&quot;,false); } }) intListAll = $(&quot;input[name='list']&quot;).length;//获取列表的个数 $(document).on(&quot;click&quot;,&quot;input[name='list']&quot;,function(){ intListChecked = $(&quot;input[name='list']:checked&quot;).length; if(intListChecked == intListAll){ $(&quot;input[name='all']&quot;).prop(&quot;checked&quot;,true); }else { $(&quot;input[name='all']&quot;).prop(&quot;checked&quot;,false); } })}","link":"/2016/03/25/js-checkbox-checkedall/"},{"title":"点击倒计时countdown","text":"12345678910111213141516171819202122232425262728293031323334// countdownvar $timeBox = $(&quot;.btn-verify&quot;), setTime = 5, //set second paramTime, Message = { second: '秒后获取', verify: '获取验证码' };function funTimeout() { paramTime--; $timeBox.html(paramTime + Message.second); //show if (paramTime == 0) { $timeBox.addClass('able').html(Message.verify); } else { setTimeout(&quot;funTimeout()&quot;, 1000); }}$(function () { $timeBox.on('click', function () { var $this = $(this); if ($this.hasClass('able')) { $this.removeClass('able'); paramTime = setTime; funTimeout(); } })}) 1&lt;div class=&quot;btn-verify able&quot;&gt;Click&lt;/div&gt;","link":"/2017/05/09/js-countdown-click/"},{"title":"jquery倒计时页面跳转","text":"1234567891011121314151617$(function(){ funTimeout(); //应用倒计时})//倒计时var strTime = 10; //设置时间var strTimeBox = $(&quot;.time-box&quot;); //数字容器function funTimeout() { strTimeBox.html(strTime); //显示数字 strTime--; if (strTime == 0) { window.opener = null; window.location.href = &quot;http://www.baidu.com/&quot;; } else { setTimeout(&quot;show()&quot;, 1000); }}","link":"/2016/03/25/js-countdown-href/"},{"title":"jquery天时分秒倒计时","text":"html 12&lt;div class=&quot;get-rt-time&quot; data-time=&quot;2100-11-11 20:20:20&quot;&gt;&lt;/div&gt;&lt;div class=&quot;get-rt-time&quot; data-time=&quot;2015-11-11 20:20:20&quot;&gt;&lt;/div&gt; js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$(function(){ $.fn.funTime=function(msg){ var data=&quot;&quot;; var _DOM=null; var funDom = function(dom){ _DOM=dom; data=$(dom).attr(&quot;data-time&quot;); data = data.replace(/-/g,&quot;/&quot;); data = Math.round((new Date(data)).getTime()/1000); var domTHML = '&lt;em class=&quot;myday&quot;&gt;&lt;/em&gt;&lt;em class=&quot;split&quot;&gt;天&lt;/em&gt;'+ '&lt;em class=&quot;myhour&quot;&gt;&lt;/em&gt;&lt;em class=&quot;split&quot;&gt;时&lt;/em&gt;'+ '&lt;em class=&quot;mymin&quot;&gt;&lt;/em&gt;&lt;em class=&quot;split&quot;&gt;分&lt;/em&gt;'+ '&lt;em class=&quot;mysec&quot;&gt;&lt;/em&gt;&lt;em class=&quot;split&quot;&gt;秒&lt;/em&gt;'; $(_DOM).append(domTHML); funMsg(msg); }; var funMsg = function(msg){ var range = data-Math.round((new Date()).getTime()/1000), secday = 86400, sechour = 3600, days = parseInt(range/secday), hours = parseInt((range%secday)/sechour), min = parseInt(((range%secday)%sechour)/60), sec = ((range%secday)%sechour)%60; if(hours &lt; 10) hours = &quot;0&quot; + hours; if(min &lt; 10) min = &quot;0&quot; + min; if(sec &lt; 10) sec = &quot;0&quot; + sec; if(hours&gt;0||min&gt;0||sec&gt;0){ $(_DOM).find(&quot;.myday&quot;).html(days); $(_DOM).find(&quot;.myhour&quot;).html(hours); $(_DOM).find(&quot;.mymin&quot;).html(min); $(_DOM).find(&quot;.mysec&quot;).html(sec); }else{ $(_DOM).hide(); $(_DOM).after(msg); } }; setInterval( funMsg,1000 ); return this.each(function(){ var $this = $(this); funDom($this); }); } //应用 $(&quot;.get-rt-time&quot;).each(function(){ var msg='&lt;div class=&quot;mask_end&quot;&gt;&lt;span&gt;活动结束&lt;/span&gt;&lt;/div&gt;'; $(this).funTime(msg); });});","link":"/2016/03/25/js-countdown-time/"},{"title":"js显示本地时间年月日","text":"1234567891011121314151617181920212223242526272829&lt;script language=&quot;JavaScript&quot; type=&quot;text/JavaScript&quot;&gt;var day=&quot;&quot;;var month=&quot;&quot;;var ampm=&quot;&quot;;var ampmhour=&quot;&quot;;var myweekday=&quot;&quot;;var year=&quot;&quot;;mydate=new Date();myweekday=mydate.getDay();mymonth=mydate.getMonth()+1;myday= mydate.getDate();myyear= mydate.getYear();year=(myyear &gt; 200) ? myyear : 1900 + myyear;if(myweekday == 0)weekday=&quot; 星期日 &quot;;else if(myweekday == 1)weekday=&quot; 星期一 &quot;;else if(myweekday == 2)weekday=&quot; 星期二 &quot;;else if(myweekday == 3)weekday=&quot; 星期三 &quot;;else if(myweekday == 4)weekday=&quot; 星期四 &quot;;else if(myweekday == 5)weekday=&quot; 星期五 &quot;;else if(myweekday == 6)weekday=&quot; 星期六 &quot;;document.write(year+&quot;年&quot;+mymonth+&quot;月&quot;+myday+&quot;日 &quot;+weekday);&lt;/script&gt;","link":"/2016/03/25/js-datetime/"},{"title":"jQuery插件的基本格式写法","text":"1234567891011121314151617181920212223242526272829303132(function($) { // funName 是控件名称 $.fn.funName = function(options) { // 设置默认值 var defaults = { choose: 'red', out: '#000' } // 如果options有的话就用options，或者使用default参数 var options = $.extend(defaults, options); // 遍历 return 链式操作 return this.each(function() { // 这里的this是jQuery对象 var $this = $(this); // 这里的this是当前循环的dom // 例当前dom和同级其它dom分别添加颜色属性 $this.css('color', options.choose).siblings().css('color', options.out); }); }})(jQuery);$(function() { // 调用 $('#demo').funName({'choose':'green', 'out':'#f00'});});","link":"/2016/09/27/js-extend/"},{"title":"fastclick.js插件使用简单说明","text":"资源下载：fastclick.js 为什么存在延迟？从点击屏幕上的元素到触发元素的 click 事件，移动浏览器会有大约 300 毫秒的等待时间。为什么这么设计呢？ 因为它想看看你是不是要进行双击（double tap）操作。 引入插件步骤1.在HTML页面中添加 1&lt;script type='application/javascript' src='/path/to/fastclick.js'&gt;&lt;/script&gt; 注：必须在页面所有Element之前加载脚本文件先实例化fastclick 2.在JS中添加fastclick的身体，推荐以下做法： 12345if ('addEventListener' in document) { document.addEventListener('DOMContentLoaded', function() { FastClick.attach(document.body); }, false); } 如果你使用了JQuery，那么JS引入就可以改用下面的写法： 123$(function() { FastClick.attach(document.body); }); 如果你使用Browserify或者其他CommonJS-style 系统,当你调用require('fastclick')时，FastClick.attach事件会被返回，加载FastClick最简单的方式就是下面的方法了： 12var attachFastClick = require('fastclick'); attachFastClick(document.body);","link":"/2016/08/16/js-fastclickjs/"},{"title":"图片上传预览, 通过file标签和js的FileReader接口","text":"用html的file标签就能实现图片上传前预览，就是通过file标签和js的FileReader接口，把选择的图片文件调用readAsDataURL方法，把图片数据转成base64字符串形式显示在页面上。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;input type=&quot;file&quot; id=&quot;xdaTanFileImg&quot; onchange=&quot;xmTanUploadImg(this)&quot; accept=&quot;image/*&quot; /&gt;&lt;img id=&quot;xmTanImg&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; //判断浏览器是否支持FileReader接口 if (typeof FileReader == 'undefined') { document.getElementById(&quot;xmTanDiv&quot;).InnerHTML = &quot;&lt;h1&gt;当前浏览器不支持FileReader接口&lt;/h1&gt;&quot;; } //选择图片，马上预览 function xmTanUploadImg(obj) { var file = obj.files[0]; console.log(obj); console.log(file); console.log(&quot;file.size = &quot; + file.size); //file.size 单位为byte var reader = new FileReader(); //读取文件过程方法 reader.onloadstart = function (e) { console.log(&quot;开始读取....&quot;); } reader.onprogress = function (e) { console.log(&quot;正在读取中....&quot;); } reader.onabort = function (e) { console.log(&quot;中断读取....&quot;); } reader.onerror = function (e) { console.log(&quot;读取异常....&quot;); } reader.onload = function (e) { console.log(&quot;成功读取....&quot;); var img = document.getElementById(&quot;xmTanImg&quot;); img.src = e.target.result; //或者 img.src = this.result; //e.target == this } reader.readAsDataURL(file) }&lt;/script&gt;","link":"/2018/01/19/js-fileReader/"},{"title":"js focus end","text":"1234export let setFocus = (target) =&gt; { let t = jQuery(target).val() jQuery(target).val('').focus().val(t)} 1setFocus('input')","link":"/2018/10/16/js-focus-end/"},{"title":"js获取url参数方法","text":"1234567891011export let getUrlParam = (name) =&gt; { let reg = new RegExp('(^|&amp;)' + name + '=([^&amp;]*)(&amp;|$)') let r = window.location.search.substr(1).match(reg) if (r != null) { return decodeURI(r[2]) } else { return null }}","link":"/2018/08/28/js-get-url-param/"},{"title":"JS历史返回代码","text":"1onclick=&quot;javascript:history.go(-1);&quot;","link":"/2016/03/25/js-history/"},{"title":"input默认提示文字","text":"12345678910111213//input默认提示文字$('.input_text_val').bind({ focus:function(){ if (this.value == this.defaultValue){ this.value=&quot;&quot;; } }, blur:function(){ if (this.value == &quot;&quot;){ this.value = this.defaultValue; } } })","link":"/2016/03/25/js-input-defaultValue/"},{"title":"判断是否是微信内置浏览器","text":"12345678910111213141516function isWeiXin(){ var ua = window.navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i) == 'micromessenger'){ return true; }else{ return false; }}$(function(){ if(isWeiXin()){ $(&quot;body&quot;).html(&quot;微信打开&quot;); }else { $(&quot;body&quot;).html(&quot;其它浏览器打开&quot;); }})","link":"/2016/03/25/js-isWeiXin/"},{"title":"jquery判断地址栏是否存在某参数","text":"1234567891011var arr = new Array();var pa;r = window.location.search;//获取地址栏问号之后的参数（包括问号）r = r.substr(1);//去除问号arr = r.split('&amp;');//切割多个参数为数组for(i=0;i&lt;arr.length;i++){ pa = arr[i].split('=');//把单个参数的名称和值拆分开 if(pa[0]=='b' &amp;&amp; pa[1]=='bbb'){//判断参数名称和值是否对应 console.log('abcdefg');//输出 }}","link":"/2016/03/25/js-location-pa/"},{"title":"跟随鼠标移动的悬浮提示框案例","text":"js部分 123456789101112131415161718$(function(){ $('&lt;div id=&quot;tip_box&quot;&gt;&lt;/div&gt;').appendTo(document.body); $(&quot;.mhover li&quot;).each(function (i) { $(this).mousemove(function (ev) { var str = $(this).data(&quot;ori&quot;); var box = $('#tip_box'); box.show(); box.html(str); var t = $(window).scrollTop(); var x = ev.clientX - box.width() - 40; var y = ev.clientY + t - 15; box.css({ left: x, top: y }); }); $(this).mouseout(function () { $(&quot;#tip_box&quot;).hide(); }); });}) html部分 1234567891011121314151617181920&lt;style type=&quot;text/css&quot;&gt; * { margin:0; padding:0; list-style:none;} .mhover { margin: 50px auto 0; width:200px; border:solid 1px #ccc;} .mhover li { height:30px; line-height:30px;} #tip_box { position:absolute; top:0; left:0; background:#f00;}&lt;/style&gt;&lt;div class=&quot;mhover&quot;&gt; &lt;ul&gt; &lt;li data-ori=&quot;这里是需要显示的文字1&quot;&gt;标题&lt;/li&gt; &lt;li data-ori=&quot;这里是需要显示的文字2&quot;&gt;标题&lt;/li&gt; &lt;li data-ori=&quot;这里是需要显示的文字3&quot;&gt;标题&lt;/li&gt; &lt;li data-ori=&quot;这里是需要显示的文字4&quot;&gt;标题&lt;/li&gt; &lt;li data-ori=&quot;这里是需要显示的文字5&quot;&gt;标题&lt;/li&gt; &lt;li data-ori=&quot;这里是需要显示的文字6&quot;&gt;标题&lt;/li&gt; &lt;li data-ori=&quot;这里是需要显示的文字7&quot;&gt;标题&lt;/li&gt; &lt;li data-ori=&quot;这里是需要显示的文字8&quot;&gt;标题&lt;/li&gt; &lt;li data-ori=&quot;这里是需要显示的文字9&quot;&gt;标题&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;","link":"/2016/03/25/js-mousemove-movebox/"},{"title":"gulpfile.js","text":"gulpfile.js放置在根目录下，启动命令’gulp serve’ // 组件gulpbrowser-sync // 自动刷新 123456789101112var gulp = require('gulp');var browserSync = require('browser-sync').create();var reload = browserSync.reload;gulp.task('serve',function(){ browserSync.init({ server:{ baseDir:'./' } }); gulp.watch(['*/*.html','*/*/*.css']).on('change',browserSync.reload);});","link":"/2016/10/10/js-nodejs-gulp-gulpfile/"},{"title":"jquery获取outerHtml包含当前节点本身的代码","text":"12$(&quot;.test&quot;).prop(&quot;outerHTML&quot;);$(&quot;.test&quot;).clone(); //或者复制方法","link":"/2016/03/25/js-outerHtml/"},{"title":"js去除url指定参数","text":"123456789101112131415161718192021222324252627282930/** * @description Remove the specified params * @param {array} params * @return {string} res */const handleRemoveParam = (params = []) =&gt; { const { origin, pathname, search } = window.location; const arr = search.substring(1).split(&quot;&amp;&quot;); let collect = []; arr.forEach((item, ind) =&gt; { params.forEach((param) =&gt; { if (item.includes(`${param}=`)) { collect = [...collect, ind]; } }); }); for(let i = 0; i &lt; collect.length; i++) { const item = i &gt; 0 ? collect[i] - i : collect[i]; arr.splice(item, 1); } const newSearch = arr.join('&amp;'); const res = newSearch ? origin + pathname + '?' + newSearch : origin + pathname; return res;}const str = handleRemoveParam(['bbb', 'aaa', 'token']);console.log(str);","link":"/2022/12/13/js-remove-url-param/"},{"title":"js正则表达式限制文本框只能输入数字,小数点,英文字母","text":"1.文本框只能输入数字代码(小数点也不能输入) 1&lt;input onkeyup=&quot;this.value=this.value.replace(/\\D/g,'')&quot; onafterpaste=&quot;this.value=this.value.replace(/\\D/g,'')&quot;&gt; 2.只能输入数字,能输小数点. 12&lt;input onkeyup=&quot;if(isNaN(value))execCommand('undo')&quot; onafterpaste=&quot;if(isNaN(value))execCommand('undo')&quot;&gt;&lt;input name=txt1 onchange=&quot;if(/\\D/.test(this.value)){alert('只能输入数字');this.value='';}&quot;&gt; 3.数字和小数点方法二 1&lt;input type=text t_value=&quot;&quot; o_value=&quot;&quot; onkeypress=&quot;if(!this.value.match(/^[\\+\\-]?\\d*?\\.?\\d*?$/))this.value=this.t_value;else this.t_value=this.value;if(this.value.match(/^(?:[\\+\\-]?\\d+(?:\\.\\d+)?)?$/))this.o_value=this.value&quot; onkeyup=&quot;if(!this.value.match(/^[\\+\\-]?\\d*?\\.?\\d*?$/))this.value=this.t_value;else this.t_value=this.value;if(this.value.match(/^(?:[\\+\\-]?\\d+(?:\\.\\d+)?)?$/))this.o_value=this.value&quot; onblur=&quot;if(!this.value.match(/^(?:[\\+\\-]?\\d+(?:\\.\\d+)?|\\.\\d*?)?$/))this.value=this.o_value;else{if(this.value.match(/^\\.\\d+$/))this.value=0+this.value;if(this.value.match(/^\\.$/))this.value=0;this.o_value=this.value}&quot;&gt; 4.只能输入字母和汉字 1&lt;input onkeyup=&quot;value=value.replace(/[\\d]/g,'') &quot;onbeforepaste=&quot;clipboardData.setData('text',clipboardData.getData('text').replace(/[\\d]/g,''))&quot; maxlength=10 name=&quot;Numbers&quot;&gt; 5.只能输入英文字母和数字,不能输入中文 1&lt;input onkeyup=&quot;value=value.replace(/[^\\w\\.\\/]/ig,'')&quot;&gt; 6.只能输入数字和英文 1&lt;input onKeyUp=&quot;value=value.replace(/[^\\d|chun]/g,'')&quot;&gt; 7.小数点后只能有最多两位(数字,中文都可输入),不能输入字母和运算符号: 1&lt;input onKeyPress=&quot;if((event.keyCode&lt;48 || event.keyCode&gt;57) &amp;&amp; event.keyCode!=46 || /\\.\\d\\d$/.test(value))event.returnValue=false&quot;&gt; 8.小数点后只能有最多两位(数字,字母,中文都可输入),可以输入运算符号: 1&lt;input onkeyup=&quot;this.value=this.value.replace(/^(\\-)*(\\d+)\\.(\\d\\d).*$/,'$1$2.$3')&quot;&gt; 9.只能输入汉字： 1&lt;input onkeyup=&quot;value=value.replace(/[^\\u4E00-\\u9FA5]/g,'')&quot; onbeforepaste=&quot;clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\u4E00-\\u9FA5]/g,''))&quot;&gt; 10.只能输入数字： 1&lt;input onkeyup=&quot;value=value.replace(/[^\\d]/g,'') &quot;onbeforepaste=&quot;clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\d]/g,''))&quot;&gt; 11.只能输入英文和数字： 1&lt;input onkeyup=&quot;value=value.replace(/[\\W]/g,'') &quot;onbeforepaste=&quot;clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\d]/g,''))&quot;&gt; 12.控制输入框只能输入文字或数字，也可以不允许输入特殊字符这里不允许输入如下字符: (像 !@#$%^&amp;* 等) 1&lt;textarea rows=2 cols=20 name=comments onKeypress=&quot;if ((event.keyCode &gt; 32 &amp;&amp; event.keyCode &lt; 48) || (event.keyCode &gt; 57 &amp;&amp; event.keyCode &lt; 65) || (event.keyCode &gt; 90 &amp;&amp; event.keyCode &lt; 97)) event.returnValue = false;&quot;&gt; 13.只禁止空格输入 1onkeyup=&quot;value=value.replace(/\\s/g,'')&quot; 14.只能输入中文和英文： 1onkeyup=&quot;value=value.replace(/[^\\a-zA-Z\\u4E00-\\u9FA5]/g,'')&quot; onbeforepaste=&quot;clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\a-zA-Z\\u4E00-\\u9FA5]/g,''))&quot;","link":"/2016/03/25/js-reqular/"},{"title":"retinajs使用摘要","text":"官方文档：retinajs 注：需要准备的图片名称格式 image.pngimage@2x.pngimage@3x.png 现在有4种实现方式： 自动交换“img”标签的”src”路径。 在内联样式中自动交换背景图像的网址。 手动指定一个高分辨率的图像不同位置。 自动创建CSS背景图像媒体查询。 12345// 自动交换&lt;img src=&quot;/images/my_image.png&quot; data-rjs=&quot;3&quot; /&gt;&lt;div style=&quot;background: url(my_image.png);&quot; data-rjs=&quot;3&quot; /&gt;// 手动指定路径&lt;img src=&quot;/images/my_image.png&quot; data-rjs=&quot;/images/2x/my_image.png&quot; /&gt; 把”data-rjs”的属性值设为3，就相当于你告知了retina.js您已创建了比传统像素密度大3倍的高分辨率图像（包括@2x和@3x的图片）。 SCSS, Sass, LESS, and Styluscss预处理是在样式表中提供高分辨率的图片，每一种预处理机制，都有4个参数： 1.path - 你的标准分辨率图像的路径。2.cap - 您准备的最高分辨率图片的等级。默认为2。3.size - background-size的属性值。默认为auto auto。4.extras - 任何其他背景属性的属性值。默认没有。 步骤： 1.添加 retina mixin到你的样式表中。2.在你的样式表中，调用retina mixin,而不是使用 background-image 1234567891011121314151617// SCSS#logo { @include retina('my_image.png', 3, 100px 50px, center center no-repeat);}// Sass#logo+retina ('my_image.png', 3, 100px 50px, center center no-repeat); // Less#logo { .retina('my_image.png', 3, 100px 50px, center center no-repeat);} // Stylus#logo retina('my_image.png', 3, 100px 50px, center center no-repeat); 编译成： 12345678910111213141516171819202122232425262728#logo { background: url(&quot;my_image.png&quot;) center center no-repeat; background-size: 100px 50px;}@media all and (-webkit-min-device-pixel-ratio: 1.5), all and (-o-min-device-pixel-ratio: 3 / 2), all and (min--moz-device-pixel-ratio: 1.5), all and (min-device-pixel-ratio: 1.5) { #item { background: url(&quot;my_image@2x.png&quot;) center center no-repeat; background-size: 100px 50px; }}@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) { #item { background: url(&quot;my_image@2x.png&quot;) center center no-repeat; background-size: 100px 50px; }}@media (-webkit-min-device-pixel-ratio: 3), (min-resolution: 288dpi) { #item { background: url(&quot;my_image@3x.png&quot;) center center no-repeat; background-size: 100px 50px; }}","link":"/2016/10/04/js-retinajs/"},{"title":"使用JS判断移动设备的终端类型","text":"方法一 12345&lt;script type=”text/javascript”&gt;if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {window.location = “mobile.html”; //可以换成http地址}&lt;/script&gt; 方法二 123456789101112131415161718192021&lt;script type=&quot;text/javascript&quot;&gt;function browserRedirect() { var sUserAgent = navigator.userAgent.toLowerCase(); var bIsIpad = sUserAgent.match(/ipad/i) == &quot;ipad&quot;; var bIsIphoneOs = sUserAgent.match(/iphone os/i) == &quot;iphone os&quot;; var bIsMidp = sUserAgent.match(/midp/i) == &quot;midp&quot;; var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == &quot;rv:1.2.3.4&quot;; var bIsUc = sUserAgent.match(/ucweb/i) == &quot;ucweb&quot;; var bIsAndroid = sUserAgent.match(/android/i) == &quot;android&quot;; var bIsCE = sUserAgent.match(/windows ce/i) == &quot;windows ce&quot;; var bIsWM = sUserAgent.match(/windows mobile/i) == &quot;windows mobile&quot;; if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) { document.writeln(&quot;phone&quot;); //window.location.href=&quot;http://www.wetools.me/&quot;; } else { document.writeln(&quot;pc&quot;); }}browserRedirect();&lt;/script&gt;","link":"/2016/03/25/js-sUserAgent/"},{"title":"两个div同步滑动（js, jquery）","text":"方法一.使用js（适用web和wap） 123456789101112131415//横向滚动条同步&lt;div id=&quot;div1&quot; style=&quot;width:500px; overflow:scroll;&quot; onscroll=&quot;document.getElementById('div2').scrollLeft = this.scrollLeft;&quot;&gt; &lt;div style=&quot;width:800px; height:50px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;div2&quot; style=&quot;width:500px; overflow:scroll;&quot; onscroll=&quot;document.getElementById('div1').scrollLeft = this.scrollLeft;&quot;&gt; &lt;div style=&quot;width:800px; height:50px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;//竖向滚动条同步&lt;div id=&quot;div1&quot; style=&quot;width:500px; overflow:scroll;&quot; onscroll=&quot;document.getElementById('div2').scrollTop = this.scrollTop;&quot;&gt; &lt;div style=&quot;width:800px; height:50px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;div2&quot; style=&quot;width:500px; overflow:scroll;&quot; onscroll=&quot;document.getElementById('div1').scrollTop = this.scrollTop;&quot;&gt; &lt;div style=&quot;width:800px; height:50px;&quot;&gt;&lt;/div&gt;&lt;/div&gt; 方法二.使用jquery（仅适用web） 12345678$('#sourceDiv').scroll( function() { $('#targetDiv').scrollTop($(this).scrollTop()); $('#targetDiv').scrollLeft($(this).scrollLeft()); }); $('#targetDiv').scroll( function() { $('#sourceDiv').scrollTop($(this).scrollTop()); $('#sourceDiv').scrollLeft($(this).scrollLeft()); });","link":"/2016/03/25/js-scroll-together/"},{"title":"div移动到顶部固定不变","text":"12345678910111213//获取要定位元素距离浏览器顶部的距离var navH = $(&quot;.hb&quot;).offset().top;//滚动条事件$(window).scroll(function(){//获取滚动条的滑动距离var scroH = $(this).scrollTop();//滚动条的滑动距离大于等于定位元素距离浏览器顶部的距离，就固定，反之就不固定if(scroH&gt;=navH){ $(&quot;.hb&quot;).css({&quot;position&quot;:&quot;fixed&quot;,&quot;top&quot;:0}); }else if(scroH&lt;navH){ $(&quot;.hb&quot;).css({&quot;position&quot;:&quot;static&quot;}); }})","link":"/2016/03/25/js-scrollTop/"},{"title":"JS Standard 代码规范","text":"这是 JavaScript standard 代码规范的全文。 掌握本规范的最好方法是安装并在自己的代码中使用它。 细则 使用两个空格进行缩进。 eslint: indent 123function hello (name) { console.log('hi', name)} 除需要转义的情况外，字符串统一使用单引号。 eslint: quotes 12console.log('hello there')$(&quot;&lt;div class='box'&gt;&quot;) 不要定义未使用的变量。 eslint: no-unused-vars 123function myFunction () { var result = something() // ✗ avoid} 关键字后面加空格。 eslint: keyword-spacing 12if (condition) { ... } // ✓ okif(condition) { ... } // ✗ avoid 函数声明时括号与函数名间加空格。 eslint: space-before-function-paren 12345function name (arg) { ... } // ✓ okfunction name(arg) { ... } // ✗ avoidrun(function () { ... }) // ✓ okrun(function() { ... }) // ✗ avoid 始终使用 === 替代 ==。例外： obj == null 可以用来检查 null || undefined。 eslint: eqeqeq 12if (name === 'John') // ✓ okif (name == 'John') // ✗ avoid 12if (name !== 'John') // ✓ okif (name != 'John') // ✗ avoid 字符串拼接操作符 (Infix operators) 之间要留空格。 eslint: space-infix-ops 123// ✓ okvar x = 2var message = 'hello, ' + name + '!' 123// ✗ avoidvar x=2var message = 'hello, '+name+'!' 逗号后面加空格。 eslint: comma-spacing 123// ✓ okvar list = [1, 2, 3, 4]function greet (name, options) { ... } 123// ✗ avoidvar list = [1,2,3,4]function greet (name,options) { ... } else 关键字要与花括号保持在同一行。 eslint: brace-style 123456// ✓ okif (condition) { // ...} else { // ...} 123456789// ✗ avoidif (condition){ // ...}else{ // ...} 多行 if 语句的的括号不能省。 eslint: curly 12// ✓ okif (options.quiet !== true) console.log('done') 1234// ✓ okif (options.quiet !== true) { console.log('done')} 123// ✗ avoidif (options.quiet !== true) console.log('done') 不要丢掉异常处理中err参数。 eslint: handle-callback-err 12345// ✓ okrun(function (err) { if (err) throw err window.alert('done')}) 1234// ✗ avoidrun(function (err) { window.alert('done')}) 使用浏览器全局变量时加上 window. 前缀。Exceptions are: document, console and navigator. eslint: no-undef 1window.alert('hi') // ✓ ok 不允许有连续多行空行。 eslint: no-multiple-empty-lines 123// ✓ okvar value = 'hello world'console.log(value) 12345// ✗ avoidvar value = 'hello world'console.log(value) 对于三元运算符 ? 和 : 与他们所负责的代码处于同一行 eslint: operator-linebreak 123456789101112// ✓ okvar location = env.development ? 'localhost' : 'www.api.com'// ✓ okvar location = env.development ? 'localhost' : 'www.api.com'// ✗ avoidvar location = env.development ? 'localhost' : 'www.api.com' 每个 var 关键字单独声明一个变量。 eslint: one-var 12345678910// ✓ okvar silent = truevar verbose = true// ✗ avoidvar silent = true, verbose = true// ✗ avoidvar silent = true, verbose = true 条件语句中赋值语句使用括号包起来。这样使得代码更加清晰可读，而不会认为是将条件判断语句的全等号（===）错写成了等号（=）。 eslint: no-cond-assign 123456789// ✓ okwhile ((m = text.match(expr))) { // ...}// ✗ avoidwhile (m = text.match(expr)) { // ...} 单行代码块两边加空格。 eslint: block-spacing 12function foo () {return true} // ✗ avoidfunction foo () { return true } // ✓ ok 对于变量和函数名统一使用驼峰命名法。 eslint: camelcase 12345function my_function () { } // ✗ avoidfunction myFunction () { } // ✓ okvar my_var = 'hello' // ✗ avoidvar myVar = 'hello' // ✓ ok 不允许有多余的行末逗号。 eslint: comma-dangle 123var obj = { message: 'hello', // ✗ avoid} 始终将逗号置于行末。 eslint: comma-style 123456789var obj = { foo: 'foo' ,bar: 'bar' // ✗ avoid}var obj = { foo: 'foo', bar: 'bar' // ✓ ok} 点号操作符须与属性需在同一行。 eslint: dot-location 12345console. log('hello') // ✗ avoidconsole .log('hello') // ✓ ok 文件末尾留一空行。 eslint: eol-last 函数调用时标识符与括号间不留间隔。 eslint: func-call-spacing 12console.log ('hello') // ✗ avoidconsole.log('hello') // ✓ ok 键值对当中冒号与值之间要留空白。 eslint: key-spacing 1234var obj = { 'key' : 'value' } // ✗ avoidvar obj = { 'key' :'value' } // ✗ avoidvar obj = { 'key':'value' } // ✗ avoidvar obj = { 'key': 'value' } // ✓ ok 构造函数要以大写字母开头。 eslint: new-cap 12345function animal () {}var dog = new animal() // ✗ avoidfunction Animal () {}var dog = new Animal() // ✓ ok 无参的构造函数调用时要带上括号。 eslint: new-parens 123function Animal () {}var dog = new Animal // ✗ avoidvar dog = new Animal() // ✓ ok 对象中定义了存值器，一定要对应的定义取值器。 eslint: accessor-pairs 1234567891011121314var person = { set name (value) { // ✗ avoid this._name = value }}var person = { set name (value) { this._name = value }, get name () { // ✓ ok return this._name }} 子类的构造器中一定要调用 super eslint: constructor-super 1234567891011class Dog { constructor () { super() // ✗ avoid }}class Dog extends Mammal { constructor () { super() // ✓ ok }} 使用数组字面量而不是构造器。 eslint: no-array-constructor 12var nums = new Array(1, 2, 3) // ✗ avoidvar nums = [1, 2, 3] // ✓ ok **避免使用 arguments.callee 和 arguments.caller**。 eslint: no-caller 1234567891011function foo (n) { if (n &lt;= 0) return arguments.callee(n - 1) // ✗ avoid}function foo (n) { if (n &lt;= 0) return foo(n - 1)} 避免对类名重新赋值。 eslint: no-class-assign 12class Dog {}Dog = 'Fido' // ✗ avoid 避免修改使用 const 声明的变量。 eslint: no-const-assign 12const score = 100score = 125 // ✗ avoid 避免使用常量作为条件表达式的条件（循环语句除外）。 eslint: no-constant-condition 1234567891011if (false) { // ✗ avoid // ...}if (x === 0) { // ✓ ok // ...}while (true) { // ✓ ok // ...} 正则中不要使用控制符。 eslint: no-control-regex 12var pattern = /\\x1f/ // ✗ avoidvar pattern = /\\x20/ // ✓ ok **不要使用 debugger**。 eslint: no-debugger 1234function sum (a, b) { debugger // ✗ avoid return a + b} 不要对变量使用 delete 操作。 eslint: no-delete-var 12var namedelete name // ✗ avoid 不要定义冗余的函数参数。 eslint: no-dupe-args 1234567function sum (a, b, a) { // ✗ avoid // ...}function sum (a, b, c) { // ✓ ok // ...} 类中不要定义冗余的属性。 eslint: no-dupe-class-members 1234class Dog { bark () {} bark () {} // ✗ avoid} 对象字面量中不要定义重复的属性。 eslint: no-dupe-keys 1234var user = { name: 'Jane Doe', name: 'John Doe' // ✗ avoid} switch 语句中不要定义重复的 case 分支。 eslint: no-duplicate-case 12345switch (id) { case 1: // ... case 1: // ✗ avoid} 同一模块有多个导入时一次性写完。 eslint: no-duplicate-imports 1234import { myFunc1 } from 'module'import { myFunc2 } from 'module' // ✗ avoidimport { myFunc1, myFunc2 } from 'module' // ✓ ok 正则中不要使用空字符。 eslint: no-empty-character-class 12const myRegex = /^abc[]/ // ✗ avoidconst myRegex = /^abc[a-z]/ // ✓ ok 不要解构空值。 eslint: no-empty-pattern 12const { a: {} } = foo // ✗ avoidconst { a: { b } } = foo // ✓ ok **不要使用 eval()**。 eslint: no-eval 12eval( &quot;var result = user.&quot; + propName ) // ✗ avoidvar result = user[propName] // ✓ ok catch 中不要对错误重新赋值。 eslint: no-ex-assign 1234567891011try { // ...} catch (e) { e = 'new value' // ✗ avoid}try { // ...} catch (e) { const newVal = 'new value' // ✓ ok} 不要扩展原生对象。 eslint: no-extend-native 1Object.prototype.age = 21 // ✗ avoid 避免多余的函数上下文绑定。 eslint: no-extra-bind 1234567const name = function () { getName()}.bind(user) // ✗ avoidconst name = function () { this.getName()}.bind(user) // ✓ ok 避免不必要的布尔转换。 eslint: no-extra-boolean-cast 123456789const result = trueif (!!result) { // ✗ avoid // ...}const result = trueif (result) { // ✓ ok // ...} 不要使用多余的括号包裹函数。 eslint: no-extra-parens 12const myFunc = (function () { }) // ✗ avoidconst myFunc = function () { } // ✓ ok switch 一定要使用 break 来将条件分支正常中断。 eslint: no-fallthrough 12345678910111213141516171819202122switch (filter) { case 1: doSomething() // ✗ avoid case 2: doSomethingElse()}switch (filter) { case 1: doSomething() break // ✓ ok case 2: doSomethingElse()}switch (filter) { case 1: doSomething() // fallthrough // ✓ ok case 2: doSomethingElse()} 不要省去小数点前面的0。 eslint: no-floating-decimal 12const discount = .5 // ✗ avoidconst discount = 0.5 // ✓ ok 避免对声明过的函数重新赋值。 eslint: no-func-assign 12function myFunc () { }myFunc = myOtherFunc // ✗ avoid 不要对全局只读对象重新赋值。 eslint: no-global-assign 1window = {} // ✗ avoid **注意隐式的 eval()**。 eslint: no-implied-eval 12setTimeout(&quot;alert('Hello world')&quot;) // ✗ avoidsetTimeout(function () { alert('Hello world') }) // ✓ ok 嵌套的代码块中禁止再定义函数。 eslint: no-inner-declarations 123if (authenticated) { function setAuthUser () {} // ✗ avoid} 不要向 RegExp 构造器传入非法的正则表达式。 eslint: no-invalid-regexp 12RegExp('[a-z') // ✗ avoidRegExp('[a-z]') // ✓ ok 不要使用非法的空白符。 eslint: no-irregular-whitespace 1function myFunc () /*&lt;NBSP&gt;*/{} // ✗ avoid **禁止使用 __iterator__**。 eslint: no-iterator 1Foo.prototype.__iterator__ = function () {} // ✗ avoid 外部变量不要与对象属性重名。 eslint: no-label-var 12345678var score = 100function game () { score: while (true) { // ✗ avoid score -= 10 if (score &gt; 0) continue score break }} 不要使用标签语句。 eslint: no-labels 1234label: while (true) { break label // ✗ avoid } 不要书写不必要的嵌套代码块。 eslint: no-lone-blocks 123456789function myFunc () { { // ✗ avoid myOtherFunc() }}function myFunc () { myOtherFunc() // ✓ ok} 不要混合使用空格与制表符作为缩进。 eslint: no-mixed-spaces-and-tabs 除了缩进，不要使用多个空格。 eslint: no-multi-spaces 12const id = 1234 // ✗ avoidconst id = 1234 // ✓ ok 不要使用多行字符串。 eslint: no-multi-str 12const message = 'Hello \\ world' // ✗ avoid new 创建对象实例后需要赋值给变量。 eslint: no-new 12new Character() // ✗ avoidconst character = new Character() // ✓ ok 禁止使用 Function 构造器。 eslint: no-new-func 1var sum = new Function('a', 'b', 'return a + b') // ✗ avoid 禁止使用 Object 构造器。 eslint: no-new-object 1let config = new Object() // ✗ avoid **禁止使用 new require**。 eslint: no-new-require 1const myModule = new require('my-module') // ✗ avoid 禁止使用 Symbol 构造器。 eslint: no-new-symbol 1const foo = new Symbol('foo') // ✗ avoid 禁止使用原始包装器。 eslint: no-new-wrappers 1const message = new String('hello') // ✗ avoid 不要将全局对象的属性作为函数调用。 eslint: no-obj-calls 1const math = Math() // ✗ avoid 不要使用八进制字面量。 eslint: no-octal 12const num = 042 // ✗ avoidconst num = '042' // ✓ ok 字符串字面量中也不要使用八进制转义字符。 eslint: no-octal-escape 1const copyright = 'Copyright \\251' // ✗ avoid 使用 __dirname 和 __filename 时尽量避免使用字符串拼接。 eslint: no-path-concat 12const pathToFile = __dirname + '/app.js' // ✗ avoidconst pathToFile = path.join(__dirname, 'app.js') // ✓ ok 使用 getPrototypeOf 来替代 **__proto__**。 eslint: no-proto 12const foo = obj.__proto__ // ✗ avoidconst foo = Object.getPrototypeOf(obj) // ✓ ok 不要重复声明变量。 eslint: no-redeclare 12345let name = 'John'let name = 'Jane' // ✗ avoidlet name = 'John'name = 'Jane' // ✓ ok 正则中避免使用多个空格。 eslint: no-regex-spaces 1234const regexp = /test value/ // ✗ avoidconst regexp = /test {3}value/ // ✓ okconst regexp = /test value/ // ✓ ok return 语句中的赋值必需有括号包裹。 eslint: no-return-assign 1234567function sum (a, b) { return result = a + b // ✗ avoid}function sum (a, b) { return (result = a + b) // ✓ ok} 避免将变量赋值给自己。 eslint: no-self-assign 1name = name // ✗ avoid 避免将变量与自己进行比较操作。 esint: no-self-compare 1if (score === score) {} // ✗ avoid 避免使用逗号操作符。 eslint: no-sequences 1if (doSomething(), !!test) {} // ✗ avoid 不要随意更改关键字的值。 eslint: no-shadow-restricted-names 1let undefined = 'value' // ✗ avoid 禁止使用稀疏数组（Sparse arrays）。 eslint: no-sparse-arrays 1let fruits = ['apple',, 'orange'] // ✗ avoid 不要使用制表符。 eslint: no-tabs 正确使用 ES6 中的字符串模板。 eslint: no-template-curly-in-string 12const message = 'Hello ${name}' // ✗ avoidconst message = `Hello ${name}` // ✓ ok 使用 this 前请确保 super() 已调用。 eslint: no-this-before-super 123456class Dog extends Animal { constructor () { this.legs = 4 // ✗ avoid super() }} 用 throw 抛错时，抛出 Error 对象而不是字符串。 eslint: no-throw-literal 12throw 'error' // ✗ avoidthrow new Error('error') // ✓ ok 行末不留空格。 eslint: no-trailing-spaces 不要使用 undefined 来初始化变量。 eslint: no-undef-init 1234let name = undefined // ✗ avoidlet namename = 'value' // ✓ ok 循环语句中注意更新循环变量。 eslint: no-unmodified-loop-condition 12for (let i = 0; i &lt; items.length; j++) {...} // ✗ avoidfor (let i = 0; i &lt; items.length; i++) {...} // ✓ ok 如果有更好的实现，尽量不要使用三元表达式。 eslint: no-unneeded-ternary 12let score = val ? val : 0 // ✗ avoidlet score = val || 0 // ✓ ok return，throw，continue 和 break 后不要再跟代码。 eslint: no-unreachable 1234function doSomething () { return true console.log('never called') // ✗ avoid} finally 代码块中不要再改变程序执行流程。 eslint: no-unsafe-finally 1234567try { // ...} catch (e) { // ...} finally { return 42 // ✗ avoid} 关系运算符的左值不要做取反操作。 eslint: no-unsafe-negation 1if (!key in obj) {} // ✗ avoid **避免不必要的 .call() 和 .apply()**。 eslint: no-useless-call 1sum.call(null, 1, 2, 3) // ✗ avoid 避免使用不必要的计算值作对象属性。 eslint: no-useless-computed-key 12const user = { ['name']: 'John Doe' } // ✗ avoidconst user = { name: 'John Doe' } // ✓ ok 禁止多余的构造器。 eslint: no-useless-constructor 1234class Car { constructor () { // ✗ avoid }} 禁止不必要的转义。 eslint: no-useless-escape 1let message = 'Hell\\o' // ✗ avoid import, export 和解构操作中，禁止赋值到同名变量。 eslint: no-useless-rename 12import { config as config } from './config' // ✗ avoidimport { config } from './config' // ✓ ok 属性前面不要加空格。 eslint: no-whitespace-before-property 12user .name // ✗ avoiduser.name // ✓ ok **禁止使用 with**。 eslint: no-with 1with (val) {...} // ✗ avoid 对象属性换行时注意统一代码风格。 eslint: object-property-newline 123456789101112const user = { name: 'Jane Doe', age: 30, username: 'jdoe86' // ✗ avoid}const user = { name: 'Jane Doe', age: 30, username: 'jdoe86' } // ✓ okconst user = { name: 'Jane Doe', age: 30, username: 'jdoe86'} // ✓ ok 代码块中避免多余留白。 eslint: padded-blocks 123456789if (user) { // ✗ avoid const name = getName()}if (user) { const name = getName() // ✓ ok} 展开运算符与它的表达式间不要留空白。 eslint: rest-spread-spacing 12fn(... args) // ✗ avoidfn(...args) // ✓ ok 遇到分号时空格要后留前不留。 eslint: semi-spacing 12for (let i = 0 ;i &lt; items.length ;i++) {...} // ✗ avoidfor (let i = 0; i &lt; items.length; i++) {...} // ✓ ok 代码块首尾留空格。 eslint: space-before-blocks 12if (admin){...} // ✗ avoidif (admin) {...} // ✓ ok 圆括号间不留空格。 eslint: space-in-parens 12getName( name ) // ✗ avoidgetName(name) // ✓ ok 一元运算符后面跟一个空格。 eslint: space-unary-ops 12typeof!admin // ✗ avoidtypeof !admin // ✓ ok 注释首尾留空格。 eslint: spaced-comment 12345//comment // ✗ avoid// comment // ✓ ok/*comment*/ // ✗ avoid/* comment */ // ✓ ok 模板字符串中变量前后不加空格。 eslint: template-curly-spacing 12const message = `Hello, ${ name }` // ✗ avoidconst message = `Hello, ${name}` // ✓ ok **检查 NaN 的正确姿势是使用 isNaN()**。 eslint: use-isnan 12if (price === NaN) { } // ✗ avoidif (isNaN(price)) { } // ✓ ok 用合法的字符串跟 typeof 进行比较操作。 eslint: valid-typeof 12typeof name === 'undefimed' // ✗ avoidtypeof name === 'undefined' // ✓ ok 自调用匿名函数 (IIFEs) 使用括号包裹。 eslint: wrap-iife 1234const getName = function () { }() // ✗ avoidconst getName = (function () { }()) // ✓ okconst getName = (function () { })() // ✓ ok yield * 中的 * 前后都要有空格。 eslint: yield-star-spacing 12yield* increment() // ✗ avoidyield * increment() // ✓ ok 请书写优雅的条件语句（avoid Yoda conditions）。 eslint: yoda 12if (42 === age) { } // ✗ avoidif (age === 42) { } // ✓ ok 关于分号 不要使用分号。 (参见：1，2，3) eslint: semi 12window.alert('hi') // ✓ okwindow.alert('hi'); // ✗ avoid 不要使用 (, [, or ` 等作为一行的开始。在没有分号的情况下代码压缩后会导致报错，而坚持这一规范则可避免出错。 eslint: no-unexpected-multiline 123456789// ✓ ok;(function () { window.alert('ok')}())// ✗ avoid(function () { window.alert('ok')}()) 12345// ✓ ok;[1, 2, 3].forEach(bar)// ✗ avoid[1, 2, 3].forEach(bar) 12345// ✓ ok;`hello`.indexOf('o')// ✗ avoid`hello`.indexOf('o') 备注：上面的写法只能说聪明过头了。 相比更加可读易懂的代码，那些看似投巧的写法是不可取的。 譬如： 1;[1, 2, 3].forEach(bar) 建议的写法是： 12var nums = [1, 2, 3]nums.forEach(bar) 拓展阅读 An Open Letter to JavaScript Leaders Regarding Semicolons JavaScript Semicolon Insertion – Everything you need to know 一个值得观看的视频： JavaScript 中的分号多余吗？- YouTube 当前主流的代码压缩方案都是基于词法（AST-based）进行的，所以在处理无分号的代码时完全没有压力（何况 JavaScript 中分号本来就不是强制的）。 一段摘抄自 “An Open Letter to JavaScript Leaders Regarding Semicolons” 这篇文章的内容： [自动化插入分号的做法]是安全可依赖的，而且其产出的代码能够在所有浏览器里很好地运行。 Closure compiler, yuicompressor, packer 还有 jsmin 都能正确地对这样的代码进行压缩处理。并没有任何性能相关的问题。 不得不说，Javascript 社区里的大牛们一直是错误的，并不能教给你最佳实践。真是让人忧伤啊。 我建议先弄清楚 JS 是怎样断句的（还有就是哪些地方看起来断了其实并没有），明白了这个后就可以随心写出漂亮的代码了。 一般来说， \\n 表示语句结束，除非： 该语句有未闭合的括号， 数组字面量， 对象字面量 或者其他不能正常结束一条语句的情况（譬如，以 . 或 , 结尾） 该语句是 -- 或者 ++ （它会将后面的内容进行自增或减） 该语句是 for()，while()，do，if() 或者 else 并且没有 { 下一行以 [，(，+，*，/，-，,，. 或者其他只会单独出现在两块内容间的二元操作符。 第一条很容易理解。即使在 JSLint 中，也允许 JSON，构造器的括号中，以及使用 var 配合 , 结尾来声明多个变量等这些情中包含 \\n。 第二条有点奇葩。 我还想不出谁会（除了这里用作讨论外）写出 i\\n++\\nj 这样的代码来，不过，顺便说一下，这种写法最后解析的结果是 i; ++j，而不是 i++; j。 第三条也容易理解。 if (x)\\ny() 等价于 if (x) { y() }。解释器会向下寻找到代码块或一条语句为止。 ; 是条合法的 JavaScript 语句。所以 if(x); 等价于 if(x){}，表示 “如果 x 为真，什么也不做。” 这种写法在循环里面可以看到，就是当条件判断与条件更新是同一个方法的时候。 不常见，但也不至于没听说过吧。 第四条就是常见的 “看，说过要加分号！” 的情形。但这些情况可以通过在语句前面加上分号来解决，如果你确定该语句跟前面的没关系的话。举个例子，假如你想这样： 12foo();[1,2,3].forEach(bar); 那么完全可以这样来写： 12foo();[1,2,3].forEach(bar) 后者的好处是分号比较瞩目，一旦习惯后便再也不会看到以 ( 和 [ 开头又不带分号的语句了。","link":"/2018/08/08/js-standard-style/"},{"title":"Query中阻止事件冒泡方式","text":"1234//event.stopPropagation();$(&quot;#div1&quot;).mousedown(function(event){ event.stopPropagation();})","link":"/2016/03/25/js-stopPropagation/"},{"title":"textarea自适应高度","text":"html部分 123456&lt;textarea id=&quot;textarea&quot; placeholder=&quot;回复内容&quot;&gt;&lt;/textarea&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;autoTextarea.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var text = document.getElementById(&quot;textarea&quot;);autoTextarea(text);// 调用&lt;/script&gt; js部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var autoTextarea = function (elem, extra, maxHeight) { extra = extra || 0; var isFirefox = !!document.getBoxObjectFor || 'mozInnerScreenX' in window, isOpera = !!window.opera &amp;&amp; !!window.opera.toString().indexOf('Opera'), addEvent = function (type, callback) { elem.addEventListener ? elem.addEventListener(type, callback, false) : elem.attachEvent('on' + type, callback); }, getStyle = elem.currentStyle ? function (name) { var val = elem.currentStyle[name]; if (name === 'height' &amp;&amp; val.search(/px/i) !== 1) { var rect = elem.getBoundingClientRect(); return rect.bottom - rect.top - parseFloat(getStyle('paddingTop')) - parseFloat(getStyle('paddingBottom')) + 'px'; }; return val; } : function (name) { return getComputedStyle(elem, null)[name]; }, minHeight = parseFloat(getStyle('height')); elem.style.resize = 'none'; var change = function () { var scrollTop, height, padding = 0, style = elem.style; if (elem._length === elem.value.length) return; elem._length = elem.value.length; if (!isFirefox &amp;&amp; !isOpera) { padding = parseInt(getStyle('paddingTop')) + parseInt(getStyle('paddingBottom')); }; scrollTop = document.body.scrollTop || document.documentElement.scrollTop; elem.style.height = minHeight + 'px'; if (elem.scrollHeight &gt; minHeight) { if (maxHeight &amp;&amp; elem.scrollHeight &gt; maxHeight) { height = maxHeight - padding; style.overflowY = 'auto'; } else { height = elem.scrollHeight - padding; style.overflowY = 'hidden'; }; style.height = height + extra + 'px'; scrollTop += parseInt(style.height) - elem.currHeight; document.body.scrollTop = scrollTop; document.documentElement.scrollTop = scrollTop; elem.currHeight = parseInt(style.height); }; }; addEvent('propertychange', change); addEvent('input', change); addEvent('focus', change); change();};","link":"/2016/03/25/js-textarea-height-auto/"},{"title":"监听textarea的值的变化&quot;propertychange&quot;","text":"js示例 1&lt;textarea onpropertychange=&quot;if(value.length&gt;100) value=value.substr(0,100)&quot;&gt;&lt;/textarea&gt; jquery示例 12345678910111213function funTestarea(){ var $testarea = $(&quot;.textarea textarea&quot;); var $b = $(&quot;.textarea b&quot;); $testarea.on(&quot;input propertychange&quot;,function(){ var $this = $(this); var strNum = $.trim($this.val()).length; if(strNum&gt;100){ $(this).val($(this).val().substr(0,100)); }else { $b.text(strNum); } });}","link":"/2016/03/25/js-textarea-propertychange/"},{"title":"js数组去重的方法","text":"12345678910111213141516171819Array.prototype.unique = function () { var r = [] var n = {} for(var i = 0; i &lt; this.length; i++) { var val = this[i] var type = typeof val if (!n[val]) { r.push(val) n[val] = [type] } else if (n[val].indexOf(type) &lt; 0) { r.push(val) n[val].push(type) } } return r} 123var arr = [112,112,34,'你好','112',112,34,'你好','str','str1', {}, {}, null, null]arr.unique() // [112, 34, &quot;你好&quot;, &quot;112&quot;, &quot;str&quot;, &quot;str1&quot;, {…}, null]","link":"/2018/10/22/js-unique/"},{"title":"js链式取值（函数解析字符串）","text":"开发中，链式取值是非常正常的操作，如：res.data.goods.list[0].price有时候会出现错误：Uncaught TypeError: Cannot read property 'goods' of undefined 通过函数解析字符串验证12345678910111213141516171819202122232425262728function get(obj, props, def) { if ((obj == null) || obj == null || typeof props !== 'string') return def; const temp = props.split('.'); const fieldArr = [].concat(temp); temp.forEach((e, i) =&gt; { if (/^(\\w+)\\[(\\w+)\\]$/.test(e)) { const matchs = e.match(/^(\\w+)\\[(\\w+)\\]$/); const field1 = matchs[1]; const field2 = matchs[2]; const index = fieldArr.indexOf(e); fieldArr.splice(index, 1, field1, field2); } }) return fieldArr.reduce((pre, cur) =&gt; { const target = pre[cur] || def; if (target instanceof Array) { return [].concat(target); } if (target instanceof Object) { return Object.assign({}, target) } return target; }, obj)} 使用: var c = { a: { b: [1, 2, 3] } } get(c, 'a.b') // [1,2,3] get(c, 'a.b[1]') // 2 get(c, 'a.d', 12) // 12","link":"/2018/10/15/js-value-chain/"},{"title":"js a链接不跳转","text":"1&lt;a href=&quot;javascript:void(0);&quot;&gt;关于我们&lt;/a&gt;","link":"/2016/03/25/js-void/"},{"title":"微信H5自定义分享在ios下失效的问题","text":"ios分享失效，表现为不显示缩略图，自定义url不正确，无法获取title等 IOS：每次切换路由，SPA的url是不会变的，发起签名请求的url参数必须是当前页面的url(就是最初进入页面时的url) Android：每次切换路由，SPA的url是会变的，发起签名请求的url参数必须是当前页面的url(不是最初进入页面时的) 如果你配置了微信分享，但没有给值。Android：会取默认值有时会有图标。IOS：肯定没有图标 如果想实现自定义： ios要在App.vue中获取并缓存该url，android不需要。需要动态判断设备系统类型 (uniapp示例) 12345//在App.vue中获取并缓存uni.setStorageSync('url',window.location.href)//在传给后端url获取返回参数配置wx.config前，加动态判断let url = uni.getSystemInfoSync().platform === 'ios' ? uni.getStorageSync('url') : window.location.href","link":"/2022/06/06/js-wechat-share-ios/"},{"title":"Javascript、Jquery获取浏览器和屏幕各种高度宽度","text":"Javascript: 1234567891011121314document.body.clientWidth //网页可见区域宽(body)document.body.clientHeight //网页可见区域高(body)document.body.offsetWidth //网页可见区域宽(body)，包括border、margin等document.body.offsetHeight //网页可见区域宽(body)，包括border、margin等document.body.scrollWidth //网页正文全文宽，包括有滚动条时的未见区域document.body.scrollHeight //网页正文全文高，包括有滚动条时的未见区域document.body.scrollTop //网页被卷去的Top(滚动条)document.body.scrollLeft //网页被卷去的Left(滚动条)window.screenTop //浏览器距离Topwindow.screenLeft //浏览器距离Leftwindow.screen.height //屏幕分辨率的高window.screen.width //屏幕分辨率的宽window.screen.availHeight //屏幕可用工作区的高window.screen.availWidth //屏幕可用工作区的宽 Jquery: 12345678$(window).height() //浏览器当前窗口可视区域高度$(document).height() //浏览器当前窗口文档的高度$(document.body).height() //浏览器当前窗口文档body的高度$(document.body).outerHeight(true) //浏览器当前窗口文档body的总高度 包括border padding margin$(window).width() //浏览器当前窗口可视区域宽度$(document).width() //浏览器当前窗口文档对象宽度$(document.body).width() //浏览器当前窗口文档body的宽度$(document.body).outerWidth(true) //浏览器当前窗口文档body的总宽度 包括border padding margin","link":"/2016/10/31/js-window-width-height/"},{"title":"zepto判断左右滑动","text":"123456789101112131415161718192021222324var startPosition, endPosition, deltaX, deltaY, moveLength; $(&quot;.content&quot;).bind('touchstart', function(e){ var touch = e.touches[0]; startPosition = { x: touch.pageX, y: touch.pageY } }) .bind('touchmove', function(e){ var touch = e.touches[0]; endPosition = { x: touch.pageX, y: touch.pageY }; deltaX = endPosition.x - startPosition.x; deltaY = endPosition.y - startPosition.y; moveLength = Math.sqrt(Math.pow(Math.abs(deltaX), 2) + Math.pow(Math.abs(deltaY), 2)); }).bind('touchend', function(e){ if(deltaX &lt; 0) { // 向左划动 console.log(&quot;向左划动&quot;); } else if (deltaX &gt; 0) { // 向右划动 console.log(&quot;向右划动&quot;); } });","link":"/2016/03/25/js-zepto-touch-direction/"},{"title":"linux软链接创建、删除和更新","text":"创建12ln -s 【目标目录】 【软链接地址】ln -s /var/www/test test 软链接创建需要同级目录下没有同名的文件 删除12rm -rf 【软链接地址】rm -rf test 软链接地址最后不能含有“/”，当含有“/”时，删除的是软链接目标目录下的资源，而不是软链接本身 修改12ln -snf 【新目标目录】 【软链接地址】ln -snf /var/www text 这里修改是指修改软链接的目标目录","link":"/2019/11/13/linux-cli-ln/"},{"title":"linux常用命令","text":"文件、目录类12345678910111213141516171819cd # 返回 home 目录（相当于cd ~）cd .. # 返回上一级目录cd - # 返回上一次所在目录,并显示其目录名cd xxx # 进入到指定目录xxxpwd # 显示当前目录的绝对路径ls -l # 列出文件的详细信息，相当于（ll）ls | grep &quot;xxx&quot; # 列出包含 &quot;xxx&quot; 关键字的文件mkdir dir # 创建一个目录mkdir -p dir/dir # 创建多级目录mkdir -m 777 dir # 创建权限为 777 的目录touch file # 创建新的空文件rmdir dir # 删除空目录rmdir -p dir/bin # 删除子空目录 bin 和其父空目录 dirrm -rf dir/bin # 删除一个目录中的一个或多个文件或目录（慎用）rm -rf xxx *.log # 删除当前目录下所有 &quot;.log&quot; 的文件（慎用）find fileName -name *.txt | xargs rm -rf # 将查找出来的文件全部删除（慎用）cp file dir/file # 将文件拷贝到另一文件中cp -R dir1 dir2 # 拷贝多个目录 (含子目录) 到指定目录mv dir1 dir2 # 将文件或目录重新命名,或者将文件从一个目录移到另一个目录中 文件查看、处理1234567891011cat file # 显示文件的内容cat -n file # 显示文件的行数编号cat file1 file2 &gt; file3 # 将文件 file1 和 file2 的内容合并之后放入 新文件 file3 中head file # 显示文件的头 10 行内容tail file # 显示文件的最后 10 行内容tail -f file # 显示文件最新追加的内容,并监视文件的变化,常用来跟踪日志文件more file # 基于vi编辑器文本过滤器,它以全屏幕的方式按页显示文本文件的内容less file # 作用与 more 十分类似, pageUp 向上翻页, pageDown 向下翻页, 按 q 退出cat file1 &gt; file2 # 覆盖导入cat file1 &gt;&gt; file # 追加导入wc -l [-m][-c][-w] file # 统计行数、字符数、字节数、单词数 文件查询、搜索1234grep keyWord # 与 cat 或者其他命令搭配使用 cat file | grep keyWordfind dir -name &quot;*.log&quot; # 搜索指定目录下的后缀为 .log 的文件find dir -name &quot;*.log&quot; -o -name &quot;*.pid&quot; # 搜索指定目录下的 &quot;.log&quot; 文件和 &quot;.pid&quot; 文件find dir -user user1 # 搜索指定目录下属于 user1 用户的文件 文本编辑 vi / vim 底行模式下1234567:set nu # 显示行号:set nonu # 不显示行号:n # 跳转到指定第 n 行:w file # 另存为:n1,n2 s/str1/str2/g # 从 n1 行到 n2 行, 将 str1 替换为 str2（从开头到结束 1,$ s/str1/str2/g）:wq # 保存并退出:q! # 强制退出不保存 文本编辑 vi / vim 命令模式下123456789G # 到末行（Shift + g）gg # 到首行dd # 删除行或剪切行u # 撤销y # 在使用 v 模式选定了某一块的时候，复制选定块到缓冲区用yw # 复制一个word （nyw或者ynw，复制n个word，n为数字）yy # 复制一行nyy # 向下复制 n 行p # 粘贴 权限管理1234567891011chmod 755 dir/file # 修改指定文件、文件夹的权限chmod -R 755 dir # 递归修改目录及其子文件、目录的权限chown user file # 改变文件的所有者chown -R user dir # 改变目录的所有者chgrp group1 file # 改变文件的所有者chgrp -R group1 dir # 改变目录的所属组chown user1:group1 file # 同时改变文件的所有者和所属组chown -R user1:group1 dir # 同时改变目录的所有者和所属组whoami # 查看当前操作用户who # 查看当前已登录系统的用户id user1 # 查看用户 user1 的归属 id 信息 压缩、解压12345678tar -cvf test.tar test.log # 仅打包,不压缩tar -xvf test.tar # 直接解包tar -zcvf test.tar.gz test.log # 打包后,以 gzip 压缩tar -zcvf test.tar.gz * # 将当前目录下所有文件压缩tar -zxvf test.tar.gz # 直接解压tar -zxvf test.tar.gz -C dir # 解压到新目录,只能是 dir 且已经存在zip test.zip * # 将当前目录下所有文件压缩为 zip 包unzip test.zip # 解压缩 zip 包 用户管理123456789101112groupadd group1 # 创建用户组groupdel group1 # 删除用户组groupmod -n group2 group1 # 将 group1 重命名 group2useradd user1 # 创建用户useradd -g group1 user1 # 创建 user1 并将其分配到 group1 组下userdel -r user1 # 删除 user1, &quot;-r&quot; 参数表示同时也删除 home 目录下的相关目录usermod -g group2 user1 # 改变 user1 的组为 group2usermod -G group2 user1 # 将 user1 的添加到 group2 组中来，同时保留原来的主组passwd # 修改当前用户密码passwd user1 # 修改 user1 用户的密码，仅限 root 用户执行su user1 # 切换到用户 user1groups user1 # 查看用户 user1 所属的组 查看命令帮助1234help cd # 用于内部命令, 如 exit、history、cd、echo 等常驻内存ls --help # 主要用于外部命令,可通过 &quot;echo $PATH&quot; 命令查看外部命令的存储路径,如 ls,vi 等man ls # 命令手册,可用于所有命令,输入&quot;q&quot;可退出type cd # 查看命令类型,内部 or 外部及命令位置 系统相关命令123456789101112131415161718192021222324shutdown -h now # 立即关机shutdown -r now # 立即重启uname -r # 查看内核版本cal # 日历date # 时间、日期date -s &quot;2015-12-22 08:00&quot; # 修改时间ntpdate time.nist.gov # 同步当前时间history # 查看历史命令记录,运行时 &quot;!&quot;+ 命令号,如 !123 运行 编号为 123 的命令ps -ef # 查看进程kill pid # 终止进程kill -9 pid # 强制终止进程top # 查看当前系统资源使用率df -h # 查看磁盘信息free -m # 查看内存信息du -h file/dir # 查看单个文件/目录大小 -h 表示以 K,M,Gdu -sh file/dir # 查看文件/目录总大小mount -o loop linux.iso /mnt/dir # 加载文件系统到指定的加载点umount /mnt/dir # 卸载已经加载的文件系统rpm -ivh xxx.rpm # 安装 rpm 包rpm -e xxx.rpm # 卸载 rpm 包yum install xxx # 安装安装包xxxyum remove xxx # 删除已安装的xxxwget http://xxxx # 下载远端 zip 包echo '' &gt; xxx # 清空xxx文件内容","link":"/2017/06/12/linux-cli/"},{"title":"markdown常用基本语法概括","text":"标题设置（让字体变大，和word的标题意思一样）在Markdown当中设置标题，有两种方式：第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 块注释（blockquote）通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。） 斜体将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来 粗体将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 无序列表在文字开头添加(, +, and -)实现无序列表。但是要注意在(, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式） 有序列表使用数字后面跟上句号。（还要有空格） 链接（Links）Markdown中有两种方式，实现链接，分别为内联方式和引用方式。内联方式： 1This is an [example link](http://example.com/). 引用方式： 1234I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 图片（Images）图片的处理方式和链接的处理方式，非常的类似。内联方式： 1![alt text](/path/to/img.jpg &quot;Title&quot;) 引用方式： 12![alt text][id] [id]: /path/to/img.jpg &quot;Title&quot; 代码（HTML中所谓的Code）实现方式有两种：第一种：简单文字出现一个代码框。使用&lt;blockquote&gt; （不是单引号而是左上角的ESC下面~中的）第二种：大片文字需要实现代码框。使用Tab和四个空格。 脚注（footnote）实现方式如下： 12hello[^hello][^hello]: hi 下划线在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）","link":"/2016/03/23/markdown-sumup/"},{"title":"Markdown 语法","text":"Markdown 的设计哲学 Markdown 的目標是實現「易讀易寫」。不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 的語法有個主要的目的：用來作為一種網路內容的寫作用語言。 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + R 预览才可以看效果。 标题Markdown 语法： 123# 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ###### 第六级标题 `&lt;h6&gt;` 强调Markdown 语法： 12345*这些文字会生成`&lt;em&gt;`*_这些文字会生成`&lt;u&gt;`_**这些文字会生成`&lt;strong&gt;`**__这些文字会生成`&lt;strong&gt;`__ 在 MWeb 中的快捷键为： CMD + U、CMD + I、CMD + B效果如下： 这些文字会生成&lt;em&gt;这些文字会生成&lt;u&gt; 这些文字会生成&lt;strong&gt;这些文字会生成&lt;strong&gt; 换行四个及以上空格加回车。如果不想打这么多空格，只要回车就为换行，请勾选：Preferences - Themes - Translate newlines to &lt;br&gt; tags 列表无序列表Markdown 语法： 1234* 项目一 无序列表 `* + 空格键`* 项目二 * 项目二的子项目一 无序列表 `TAB + * + 空格键` * 项目二的子项目二 在 MWeb 中的快捷键为： Option + U效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： 123451. 项目一 有序列表 `数字 + . + 空格键`2. 项目二 3. 项目三 1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键` 2. 项目三的子项目二 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 `- + 空格 + [ ]`- [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： 12![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)格式: ![Alt Text](url) Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： 链接Markdown 语法： 123email &lt;example@example.com&gt;[GitHub](http://github.com)自动生成连接 &lt;http://www.github.com/&gt; Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： example@example.com连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： 123某某说:&gt; 第一行引用&gt; 第二行费用文字 CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用第二行费用文字 行内代码Markdown 语法： 1像这样即可：`&lt;addr&gt;` `code` CMD + K 可插入Markdown语法。效果如下： 像这样即可：&lt;addr&gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) { if(arg) { $.facebox({div:'#foo'}) }} CMD + Shift + K 可插入Markdown语法。效果如下： 123456function fancyAlert(arg) { if(arg) { $.facebox({div:'#foo'}) } } 顺序图或流程图Markdown 语法： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 效果如下（ Preferences - Themes - Enable sequence &amp; flow chart 才会看到效果 ）： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： ~~删除这些~~ 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： *** ***** - - - 效果如下： MathJaxMarkdown 语法： 12345678块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\\\\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\\\]行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多 Actions-&gt;Insert Read More Comment 或者 Command + .注 阅读更多的功能只用在生成网站或博客时。 TOCMarkdown 语法： 1[TOC] 效果如下： [TOC]","link":"/2016/04/14/markdown/"},{"title":"mac下 navicat 如何连接本地 mysql（mamp pro 服务器）","text":"打开mac 下的 navicat 建立相应的连接，点击设置连接属性。 点击advanced use socket ,打勾。输入/Applications/MAMP/tmp/mysql/mysql.sock","link":"/2016/07/18/mysql-navicat-mysql/"},{"title":"create-react-app 使用摘要","text":"Github地址: create-react-app 安装、启动命令 12345npm install -g create-react-appcreate-react-app my-appcd my-appnpm start 初始目录结构 1234567891011121314151617my-app├── README.md├── node_modules├── package.json├── .gitignore├── public│ └── favicon.ico│ └── index.html│ └── manifest.json└── src └── App.css └── App.js └── App.test.js └── index.css └── index.js └── logo.svg └── registerServiceWorker.js","link":"/2018/02/22/npm-create-react-app/"},{"title":"php提取文字并去除html标记，超出省略号表示","text":"1234567function cutArticle($data) { $data=strip_tags($data);//去除html标记 $pattern = &quot;/&amp;[a-zA-Z]+;/&quot;;//去除特殊符号 $data=preg_replace($pattern,'',$data); $data = mb_strimwidth($data,0,150,'....','UTF-8'); return $data;}","link":"/2016/06/20/php-cut-article/"},{"title":"php发出http(post,get)请求","text":"web service model很多时候需要使用别的web service来建造自己的web service，这就需要到使用服务器端进行请求http操作，post或者get请求。 1234567891011121314151617181920/** * PHP发送请求获取数据 * @param [type] $url [description] * @param [type] $post_data [description] * @return [type] $result [description] */function send_post($url, $post_data) { $postdata = http_build_query($post_data); $options = array( 'http' =&gt; array( 'method' =&gt; 'POST',//or GET 'header' =&gt; 'Content-type:application/x-www-form-urlencoded', 'content' =&gt; $postdata, 'timeout' =&gt; 15 * 60 // 超时时间（单位:s） ) ); $context = stream_context_create($options); $result = file_get_contents($url, false, $context); return $result;} 以上是发送请求的函数，具体操作如下： 123456//使用方法$post_data = array( 'username' =&gt; 'stclair2201', 'password' =&gt; 'handan');$result=send_post('http://localhost/ServiceProvider/index.php/Index/getService', $post_data);","link":"/2016/07/23/php-http/"},{"title":"Regular Expressions 正则表达式语法","text":"普通字符什么叫普通字符？ 当我们写a的时候，我们指的就是a；当我们写爱的时候，我们指的就是爱。 12'hello 😀 regex'.match(/😀/);// [&quot;😀&quot;, index: 6, input: &quot;hello 😀 regex&quot;, groups: undefined] 这就是普通字符，它在正则中的含义就是检索它本身。除了正则规定的部分字符外，其余的都是普通字符，包括各种人类语言，包括emoji，只要能够表达为字符串。 开始与结束^字符的英文是caret，翻译成中文是脱字符。不要问我，又不是我翻译的。它在正则中属于元字符，通常代表的意义是文本的开始。说通常是因为当它在字符组中[^abc]另有含义。 什么叫文本的开始？就是如果它是正则主体的第一个符号，那紧跟着它的字符必须是被匹配文本的第一个字符。 12'regex'.match(/^r/);// [&quot;r&quot;, index: 0, input: &quot;regex&quot;, groups: undefined] 问题来了，如果^不是正则的第一个符号呢？ 12'regex'.match(/a^r/);// null 所以呀，关于它有三点需要注意： 作为匹配文本开始元字符的时候必须是正则主体的第一个符号，否则正则无效。 它匹配的是一个位置，而不是具体的文本。 它在其他规则中有另外的含义。 $字符与^正好相反。它代表文本的结束，并且没有其他含义(其实是有的，但不是在正则主体内)。同样，它必须是正则主体的最后一个符号。 12'regex'.match(/x$/);// [&quot;x&quot;, index: 4, input: &quot;regex&quot;, groups: undefined] ^与$特殊的地方在于它匹配的是一个位置。位置不像字符，它看不见，所以更不容易理解。 转义我们现在已经知道$匹配文本的结束位置，它是元字符。但是如果我想匹配$本身呢？匹配一个美元符号的需求再常见不过了吧。所以我们得将它贬为庶民。 \\反斜杠就是干这个的。 12'price: $3.6'.match(/\\$[0-9]+\\.[0-9]+$/);// [&quot;$3.6&quot;, index: 7, input: &quot;price: $3.6&quot;, groups: undefined] 上面的例子有点超纲了，超纲的部分先不管。 你可以认为\\也是一个元字符，它跟在另一个元字符后面，就能还原它本来的含义。 如果有两个\\呢？那就是转义自身了。如果有三个\\呢？我们得分成两段去理解。以此类推。 普通字符前面跟了一个\\是什么效果？首先它们是一个整体，然后普通字符转义后还是普通字符。 带反斜杠的元字符一般来说，普通字符前面带反斜杠还是普通字符，但是有一些普通字符，带反斜杠后反而变成了元字符。 要怪只能怪计算机领域的常用符号太少了。 元字符 含义 \\b 匹配一个单词边界(boundary) \\B 匹配一个非单词边界 \\d 匹配一个数字字符(digit) \\D 匹配一个非数字字符 \\s 匹配一个空白字符(space) \\S 匹配一个非空白字符 \\w 匹配一个字母或者一个数字或者一个下划线(word) \\W 匹配一个字母、数字和下划线之外的字符 你这么聪明，肯定一眼就看出来，大写代表反义。对，就是这么好记。 \\b元字符\\b匹配的也是一个位置，而不是一个字符。单词和空格之间的位置，就是所谓单词边界。 1234'hello regex'.match(/\\bregex$/);// [&quot;regex&quot;, index: 6, input: &quot;hello regex&quot;, groups: undefined]'hello regex'.match(/\\Bregex$/);// null 所谓单词边界，对中文等其他语言是无效的。 1234'jiangshuying gaoyuanyuan huosiyan'.match(/\\bgaoyuanyuan\\b/);// [&quot;gaoyuanyuan&quot;, index: 13, input: &quot;jiangshuying gaoyuanyuan huosiyan&quot;, groups: undefined]'江疏影 高圆圆 霍思燕'.match(/\\b高圆圆\\b/);// null 所以\\b翻译一下就是^\\w|\\w$|\\W\\w|\\w\\W。 \\d元字符\\d匹配一个数字，注意，这里的数字不是指JavaScript中的数字类型，因为文本全是字符串。它指的是代表数字的字符。 12'123'.match(/\\d/);// [&quot;1&quot;, index: 0, input: &quot;123&quot;, groups: undefined] \\s元字符\\s匹配一个空白字符。 这里需要解释一下什么是空白字符。 空白字符不是空格，它是空格的超集。很多人说它是\\f\\n\\r\\t\\v的总和，其中\\f是换页符，\\n是换行符，\\r是回车符，\\t是水平制表符，\\v是垂直制表符。是这样么？ 1234567891011121314'a b'.match(/\\w\\s\\w/);// [&quot;a b&quot;, index: 0, input: &quot;a b&quot;, groups: undefined]'a b'.match(/\\w\\f\\w/);// null'a b'.match(/\\w\\n\\w/);// null'a b'.match(/\\w\\r\\w/);// null'a b'.match(/\\w\\t\\w/);// null'a b'.match(/\\w\\v\\w/);// null'a b'.match(/\\w \\w/);// [&quot;a b&quot;, index: 0, input: &quot;a b&quot;, groups: undefined] 这样说的人，明显是没有做过实验。其实正确的写法是空格\\f\\n\\r\\t\\v的总和，集合里面包含一个空格，可千万别忽略了。诶，难道空格在正则中的写法就是空一格么，是的，就是这样随意。 这个集合中很多都是不可打印字符，估计只有\\n是我们的老朋友。所以，如果不需要区分空格和换行的话，那就大胆的用\\s吧。 \\w元字符\\w匹配一个字母或者一个数字或者一个下划线。为什么要将它们放一起？想一想JavaScript中的变量规则，包括很多应用的用户名都只能是这三样，所以把它们放一起挺方便的。 不过要注意，字母指的是26个英文字母，其他的不行。 12'正则'.match(/\\w/);// null 负阴抱阳如果我们将大写和小写的带反斜杠的元字符组合在一起，就能匹配任何字符。是的，不针对任何人。 12'@regex'.match(/[\\s\\S]/);// [&quot;@&quot;, index: 0, input: &quot;@regex&quot;, groups: undefined] 方括号的含义我们先按下不表。 道生一.在正则中的含义仙风道骨，它匹配换行符之外的任意单个字符。 如果文本不存在换行符，那么.和[\\b\\B]和[\\d\\D]和[\\s\\S]和[\\w\\W]是等价的。 如果文本存在换行符，那么(.|\\n)和[\\b\\B]和[\\d\\D]和[\\s\\S]和[\\w\\W]是等价的。 12'@regex'.match(/./);// [&quot;@&quot;, index: 0, input: &quot;@regex&quot;, groups: undefined] 量词前面我们一直在强调，一个元字符只匹配一个字符。即便强大如.它也只能匹配一个。 那匹配gooooogle的正则是不是得写成/gooooogle/呢？ 正则冷笑，并向你发射一个蔑视。 如果匹配的模式有重复，我们可以声明它重复的次数。 量词 含义 ? 重复零次或者一次 + 重复一次或者多次，也就是至少一次 * 重复零次或者多次，也就是任意次数 {n} 重复n次 {n,} 重复n次或者更多次 {n,m} 重复n次到m次之间的次数，包含n次和m次 有三点需要注意： ?在诸如匹配http协议的时候非常有用，就像这样：/http(s)?/。它在正则中除了是量词还有别的含义，后面会提到。 我们习惯用/.*/来匹配若干对我们没有价值的文本，它的含义是若干除换行符之外的字符。比如我们需要文本两头的格式化信息，中间是什么无所谓，它就派上用场了。不过它的性能可不好。 {n,m}之间不能有空格，空格在正则中是有含义的。 关于量词最令人困惑的是：它重复什么？ 它重复紧贴在它前面的某个集合。第一点，必须是紧贴在它前面；第二点，重复一个集合。最常见的集合就是一个字符，当然正则中有一些元字符能够将若干字符变成一个集合，后面会讲到。 12'gooooogle'.match(/go{2,5}gle/);// [&quot;gooooogle&quot;, index: 0, input: &quot;gooooogle&quot;, groups: undefined] 如果一个量词紧贴在另一个量词后面会怎样？ 12'gooooogle'.match(/go{2,5}+gle/);// Uncaught SyntaxError: Invalid regular expression: /go{2,5}+gle/: Nothing to repeat 贪婪模式与非贪婪模式前面提到量词不能紧跟在另一个量词后面，马上要👋👋打脸了。 1234'https'.match(/http(s)?/);// [&quot;https&quot;, &quot;s&quot;, index: 0, input: &quot;https&quot;, groups: undefined]'https'.match(/http(s)??/);// [&quot;http&quot;, undefined, index: 0, input: &quot;https&quot;, groups: undefined] 然而，我的脸是这么好打的？ 紧跟在?后面的?它不是一个量词，而是一个模式切换符，从贪婪模式切换到非贪婪模式。 贪婪模式在正则中是默认的模式，就是在既定规则之下匹配尽可能多的文本。因为正则中有量词，它的重复次数可能是一个区间，这就有了取舍。 紧跟在量词之后加上?就可以开启非贪婪模式。怎么省事怎么来。 这里的要点是，?必须紧跟着量词，否则的话它自己就变成量词了。 字符组正则中的普通字符只能匹配它自己。如果我要匹配一个普通字符，但是我不确定它是什么，怎么办？ 12'grey or gray'.match(/gr[ae]y/);// [&quot;grey&quot;, index: 0, input: &quot;grey or gray&quot;, groups: undefined] 方括号在正则中表示一个区间，我们称它为字符组。 首先，字符组中的字符集合只是所有的可选项，最终它只能匹配一个字符。 然后，字符组是一个独立的世界，元字符不需要转义。 12'$'.match(/[$&amp;@]/);// [&quot;$&quot;, index: 0, input: &quot;$&quot;, groups: undefined] 最后，有两个字符在字符组中有特殊含义。 ^在字符组中表示取反，不再是文本开始的位置了。 12'regex'.match(/[^abc]/);// [&quot;r&quot;, index: 0, input: &quot;regex&quot;, groups: undefined] 如果我就要^呢？前面已经讲过了，转义。 -本来是一个普通字符，在字符组中摇身一变成为连字符。 12'13'.match(/[1-9]3/);// [&quot;13&quot;, index: 0, input: &quot;13&quot;, groups: undefined] 连字符的意思是匹配范围在它的左边字符和右边字符之间。 如果我这样呢？ 12'abc-3'.match(/[0-z]/);// [&quot;a&quot;, index: 0, input: &quot;abc-3&quot;, groups: undefined] 12'xyz-3'.match(/[0-c]/);// [&quot;3&quot;, index: 4, input: &quot;xyz-3&quot;, groups: undefined] 12'xyz-3'.match(/[0-$]/);// Uncaught SyntaxError: Invalid regular expression: /[0-$]/: Range out of order in character class 发现什么了没有？只有两种字符是可以用连字符的：英文字母和数字。而且英文字母可以和数字连起来，英文字母的顺序在后面。这和扑克牌1 2 3 4 5 6 7 8 9 10 J Q K是一个道理。 捕获组与非捕获组我们已经知道量词是怎么回事了，我们也知道量词只能重复紧贴在它前面的字符。 如果我要重复的是一串字符呢？ 1234'i love you very very very much'.match(/i love you very +much/);// null'i love you very very very much'.match(/i love you v+e+r+y+ +much/);// null 这样肯定是不行的。是时候请圆括号出山了。 12'i love you very very very much'.match(/i love you (very )+much/);// [&quot;i love you very very very much&quot;, &quot;very &quot;, index: 0, input: &quot;i love you very very very much&quot;, groups: undefined] 圆括号的意思是将它其中的字符集合打包成一个整体，然后量词就可以操作这个整体了。这和方括号的效果是完全不一样的。 而且默认的，圆括号的匹配结果是可以捕获的。 正则内捕获现在我们有一个需求，匹配&lt;div&gt;标签。 12'&lt;div&gt;hello regex&lt;/div&gt;'.match(/&lt;div&gt;.*&lt;\\/div&gt;/);// [&quot;&lt;div&gt;hello regex&lt;/div&gt;&quot;, index: 0, input: &quot;&lt;div&gt;hello regex&lt;/div&gt;&quot;, groups: undefined] 这很简单。但如果我要匹配的是任意标签，包括自定义的标签呢？ 12'&lt;App&gt;hello regex&lt;/App&gt;'.match(/&lt;([a-zA-Z]+)&gt;.*&lt;\\/\\1&gt;/);// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, &quot;App&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, groups: undefined] 这时候就要用到正则的捕获特性。正则内捕获使用\\数字的形式，分别对应前面的圆括号捕获的内容。这种捕获的引用也叫反向引用。 我们来看一个更复杂的情况： 12'&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;'.match(/&lt;((A|a)pp)&gt;(hello regex)+&lt;\\/\\1&gt;&lt;p&gt;\\2&lt;\\/p&gt;&lt;p&gt;\\3&lt;\\/p&gt;/);// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&quot;, &quot;App&quot;, &quot;A&quot;, &quot;hello regex&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&quot;, groups: undefined] 如果有嵌套的圆括号，那么捕获的引用是先递归的，然后才是下一个顶级捕获。所谓深度优先。 正则外捕获1234'@abc'.match(/@(abc)/);// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]RegExp.$1;// &quot;abc&quot; 没错，RegExp就是构造正则的构造函数。如果有捕获组，它的实例属性$数字会显示对应的引用。 如果有多个正则呢？ 123456'@abc'.match(/@(abc)/);// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]'@xyz'.match(/@(xyz)/);// [&quot;@xyz&quot;, &quot;xyz&quot;, index: 0, input: &quot;@xyz&quot;, groups: undefined]RegExp.$1;// &quot;xyz&quot; RegExp构造函数的引用只显示最后一个正则的捕获。 另外还有一个字符串实例方法也支持正则捕获的引用，它就是replace方法。 12'hello **regex**'.replace(/\\*{2}(.*)\\*{2}/, '&lt;strong&gt;$1&lt;/strong&gt;');// &quot;hello &lt;strong&gt;regex&lt;/strong&gt;&quot; 实际上它才是最常用的引用捕获的方式。 捕获命名 这是ES2018的新特性。 使用\\数字引用捕获必须保证捕获组的顺序不变。现在开发者可以给捕获组命名了，有了名字以后，引用起来更加确定。 12'&lt;App&gt;hello regex&lt;/App&gt;'.match(/&lt;(?&lt;tag&gt;[a-zA-Z]+)&gt;.*&lt;\\/\\k&lt;tag&gt;&gt;/);// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, &quot;App&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, groups: {tag: &quot;App&quot;}] 在捕获组内部最前面加上?&lt;key&gt;，它就被命名了。使用\\k&lt;key&gt;语法就可以引用已经命名的捕获组。 是不是很简单？ 通常情况下，开发者只是想在正则中将某些字符当成一个整体看待。捕获组很棒，但是它做了额外的事情，肯定需要额外的内存占用和计算资源。于是正则又有了非捕获组的概念。 1234'@abc'.match(/@(abc)/);// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]'@abc'.match(/@(?:abc)/);// [&quot;@abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined] 只要在圆括号内最前面加上?:标识，就是告诉正则引擎：我只要这个整体，不需要它的引用，你就别费劲了。从上面的例子也可以看出来，match方法返回的结果有些许不一样。 个人观点：我觉得正则的捕获设计应该反过来，默认不捕获，加上?:标识后才捕获。因为大多数时候开发者是不需要捕获的，但是它又懒得加?:标识，会有些许性能浪费。 分支有时候开发者需要在正则中使用或者。 12'高圆圆'.match(/陈乔恩|高圆圆/);// [&quot;高圆圆&quot;, index: 0, input: &quot;高圆圆&quot;, groups: undefined] |就代表或者。字符组其实也是一个多选结构，但是它们俩有本质区别。字符组最终只能匹配一个字符，而分支匹配的是左边所有的字符或者右边所有的字符。 我们来看一个例子： 12'我喜欢高圆圆'.match(/我喜欢陈乔恩|高圆圆/);// [&quot;高圆圆&quot;, index: 3, input: &quot;我喜欢高圆圆&quot;, groups: undefined] 因为|是将左右两边一切两半，然后匹配左边或者右边。所以上面的正则显然达不到我们想要的效果。这个时候就需要一个东西来缩小分支的范围。诶，你可能已经想到了： 12'我喜欢高圆圆'.match(/我喜欢(?:陈乔恩|高圆圆)/);// [&quot;我喜欢高圆圆&quot;, index: 0, input: &quot;我喜欢高圆圆&quot;, groups: undefined] 没错，就是圆括号。 零宽断言正则中有一些元字符，它不匹配字符，而是匹配一个位置。比如之前提到的^和$。^的意思是说这个位置应该是文本开始的位置。 正则还有一些比较高级的匹配位置的语法，它匹配的是：在这个位置之前或之后应该有什么内容。 零宽(zero-width)是什么意思？指的就是它匹配一个位置，本身没有宽度。 断言(assertion)是什么意思？指的是一种判断，断言之前或之后应该有什么或应该没有什么。 零宽肯定先行断言所谓的肯定就是判断有什么，而不是判断没有什么。 而先行指的是向前看(lookahead)，断言的这个位置是为前面的规则服务的。 语法很简单：圆括号内最左边加上?=标识。 12'CoffeeScript JavaScript javascript'.match(/\\b\\w{4}(?=Script\\b)/);// [&quot;Java&quot;, index: 13, input: &quot;CoffeeScript JavaScript javascript&quot;, groups: undefined] 上面匹配的是四个字母，这四个字母要满足以下条件：紧跟着的应该是Script字符串，而且Script字符串应该是单词的结尾部分。 所以，零宽肯定先行断言的意思是：现在有一段正则语法，用这段语法去匹配给定的文本。但是，满足条件的文本不仅要匹配这段语法，紧跟着它的必须是一个位置，这个位置又必须满足一段正则语法。 说的再直白点，我要匹配一段文本，但是这段文本后面必须紧跟着另一段特定的文本。零宽肯定先行断言就是一个界碑，我要满足前面和后面所有的条件，但是我只要前面的文本。 我们来看另一种情况： 12'CoffeeScript JavaScript javascript'.match(/\\b\\w{4}(?=Script\\b)\\w+/);// [&quot;JavaScript&quot;, index: 13, input: &quot;CoffeeScript JavaScript javascript&quot;, groups: undefined] 上面的例子更加直观，零宽肯定先行断言已经匹配过Script一次了，后面的\\w+却还是能匹配Script成功，足以说明它的零宽特性。它为紧贴在它前面的规则服务，并且不影响后面的匹配规则。 零宽肯定后行断言先行是向前看，那后行就是向后看(lookbehind)咯。 语法是圆括号内最左边加上?&lt;=标识。 12'演员高圆圆 将军霍去病 演员霍思燕'.match(/(?&lt;=演员)霍\\S+/);// [&quot;霍思燕&quot;, index: 14, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined] 一个正则可以有多个断言： 12'演员高圆圆 将军霍去病 演员霍思燕'.match(/(?&lt;=演员)霍.+?(?=\\s|$)/);// [&quot;霍思燕&quot;, index: 14, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined] 零宽否定先行断言肯定是判断有什么，否定就是判断没有什么咯。 语法是圆括号内最左边加上?!标识。 12'TypeScript Perl JavaScript'.match(/\\b\\w{4}(?!Script\\b)/);// [&quot;Perl&quot;, index: 11, input: &quot;TypeScript Perl JavaScript&quot;, groups: undefined] 零宽否定后行断言语法是圆括号最左边加上?&lt;!标识。 12'演员高圆圆 将军霍去病 演员霍思燕'.match(/(?&lt;!演员)霍\\S+/);// [&quot;霍去病&quot;, index: 8, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined] 修饰符正则表达式除了主体语法，还有若干可选的模式修饰符。 写法就是将修饰符安插在正则主体的尾巴上。比如这样：/abc/gi。 g修饰符g是global的缩写。默认情况下，正则从左向右匹配，只要匹配到了结果就会收工。g修饰符会开启全局匹配模式，找到所有匹配的结果。 1234'演员高圆圆 将军霍去病 演员霍思燕'.match(/(?&lt;=演员)\\S+/);// [&quot;高圆圆&quot;, index: 2, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]'演员高圆圆 将军霍去病 演员霍思燕'.match(/(?&lt;=演员)\\S+/g);// [&quot;高圆圆&quot;, &quot;霍思燕&quot;] i修饰符i是ignoreCase的缩写。默认情况下，/z/是无法匹配Z的，所以我们有时候不得不这样写：/[a-zA-Z]/。i修饰符可以全局忽略大小写。 很多时候我们不在乎文本是大写、小写还是大小写混写，这个修饰符还是很有用的。 1234'javascript is great'.match(/JavaScript/);// null'javascript is great'.match(/JavaScript/i);// [&quot;javascript&quot;, index: 0, input: &quot;javascript is great&quot;, groups: undefined] m修饰符m是multiline的缩写。这个修饰符有特定起作用的场景：它要和^和$搭配起来使用。默认情况下，^和$匹配的是文本的开始和结束，加上m修饰符，它们的含义就变成了行的开始和结束。 123456789101112131415`abcxyz`.match(/xyz/);// [&quot;xyz&quot;, index: 5, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]`abcxyz`.match(/^xyz$/);// null`abcxyz`.match(/^xyz$/m);// [&quot;xyz&quot;, index: 5, input: &quot;↵abc↵xyz↵&quot;, groups: undefined] y修饰符 这是ES2015的新特性。 y是sticky的缩写。y修饰符有和g修饰符重合的功能，它们都是全局匹配。所以重点在sticky上，怎么理解这个粘连呢？ g修饰符不挑食，匹配完一个接着匹配下一个，对于文本的位置没有要求。但是y修饰符要求必须从文本的开始实施匹配，因为它会开启全局匹配，匹配到的文本的下一个字符就是下一次文本的开始。这就是所谓的粘连。 12345678'a bag with a tag has a mag'.match(/\\wag/g);// [&quot;bag&quot;, &quot;tag&quot;, &quot;mag&quot;]'a bag with a tag has a mag'.match(/\\wag/y);// null'bagtagmag'.match(/\\wag/y);// [&quot;bag&quot;, index: 0, input: &quot;bagtagmag&quot;, groups: undefined]'bagtagmag'.match(/\\wag/gy);// [&quot;bag&quot;, &quot;tag&quot;, &quot;mag&quot;] 有人肯定发现了猫腻：你不是说y修饰符是全局匹配么？看上面的例子，单独一个y修饰符用match方法怎么并不是全局匹配呢？ 诶，这里说来就话长了。 长话短说呢，就涉及到y修饰符的本质是什么。它的本质有二： 全局匹配(先别着急打我)。 从文本的lastIndex位置开始新的匹配。lastIndex是什么？它是正则表达式的一个属性，如果是全局匹配，它用来标注下一次匹配的起始点。这才是粘连的本质所在。 不知道你们发现什么了没有：lastIndex是正则表达式的一个属性。而上面例子中的match方法是作用在字符串上的，都没有lastIndex属性，休怪人家工作不上心。 1234567const reg = /\\wag/y;reg.exec('bagtagmag');// [&quot;bag&quot;, index: 0, input: &quot;bagtagmag&quot;, groups: undefined]reg.exec('bagtagmag');// [&quot;tag&quot;, index: 3, input: &quot;bagtagmag&quot;, groups: undefined]reg.exec('bagtagmag');// [&quot;mag&quot;, index: 6, input: &quot;bagtagmag&quot;, groups: undefined] 咱们换成正则方法exec，多次执行，正则的lastIndex在变，匹配的结果也在变。全局匹配无疑了吧。 s修饰符 这是ES2018的新特性。 s不是dotAll的缩写。s修饰符要和.搭配使用，默认情况下，.匹配除了换行符之外的任意单个字符，然而它还没有强大到无所不能的地步，所以正则索性给它开个挂。 s修饰符的作用就是让.可以匹配任意单个字符。 s是singleline的缩写。 12345678910`abcxyz`.match(/c.x/);// null`abcxyz`.match(/c.x/s);// [&quot;c↵x&quot;, index: 3, input: &quot;↵abc↵xyz↵&quot;, groups: undefined] u修饰符 这是ES2015的新特性。 u是unicode的缩写。有一些Unicode字符超过一个字节，正则就无法正确的识别它们。u修饰符就是用来处理这些不常见的情况的。 1234'𠮷'.match(/^.$/);// null'𠮷'.match(/^.$/u);// [&quot;𠮷&quot;, index: 0, input: &quot;𠮷&quot;, groups: undefined] 𠮷念jí，与吉同义。 本文摘自 https://github.com/veedrin/horseshoe","link":"/2022/02/05/regex-grammar/"},{"title":"Regular Expressions 正则表达式方法","text":"RegExpRegExp是正则表达式的构造函数。 使用构造函数创建正则表达式有多种写法： 12345678new RegExp('abc');// /abc/new RegExp('abc', 'gi');// /abc/ginew RegExp(/abc/gi);// /abc/ginew RegExp(/abc/m, 'gi');// /abc/gi 它接受两个参数：第一个参数是匹配模式，可以是字符串也可以是正则表达式；第二个参数是修饰符。 如果第一个参数的正则表达式定义了修饰符，第二个参数又有值，则以第二个参数定义的修饰符为准，这是ES2015的新特性。 使用构造函数一般用于需要动态构造正则表达式的场景，性能不如字面量写法。 我们来看看它的实例属性： lastIndex属性。它的作用是全局匹配时标记下一次匹配开始的位置，全局匹配的抓手就是它。 source属性。它的作用是存储正则模式的主体。比如/abc/gi中的abc。 对应的修饰符属性。目前有global、ignoreCase、multiline、sticky、dotAll、unicode属性，返回布尔值表明是否开启对应修饰符。 flags属性。返回所有的修饰符。 matchmatch是String实例方法。 它的作用是根据参数返回匹配结果，取名match也是非常恰当了。 它接受一个正则表达式作为唯一参数。 可是字符串也可以作为参数怎么解释？ 12'abc'.match('b');// [&quot;b&quot;, index: 1, input: &quot;abc&quot;, groups: undefined] 这是因为match方法内部会隐式的调用new RegExp()将其转换成一个正则实例。 match方法的返回值可以分为三种情况。 匹配失败没什么可说的，返回null。 非全局匹配返回一个数组。 数组的第一项是匹配结果。如果不传参则匹配结果为空字符串。 12'abc'.match();// [&quot;&quot;, index: 0, input: &quot;abc&quot;, groups: undefined] 如果正则参数中有捕获组，捕获的结果在数组中从第二项开始依次排列。有捕获组但是没有捕获内容则显示undefined。 12'@abc2018'.match(/@([a-z]+)([A-Z]+)?/);// [&quot;@abc&quot;, &quot;abc&quot;, undefined, index: 0, input: &quot;@abc2018&quot;, groups: undefined] 数组有一个index属性，标明匹配结果在文本中的起始位置。 数组有一个input属性，显示源文本。 数组有一个groups属性，它存储的不是捕获组的信息，而是捕获命名的信息。 12'@abc2018'.match(/@(?&lt;lowerCase&gt;[a-z]+)(?&lt;upperCase&gt;[A-Z]+)?/);// [&quot;@abc&quot;, &quot;abc&quot;, undefined, index: 0, input: &quot;@abc2018&quot;, groups: { lowerCase: &quot;abc&quot;, upperCase: undefined }] 全局匹配返回一个数组。 捕获的若干结果在数组中依次排列。因为要返回所有匹配的结果，其他的信息，包括捕获组和若干属性就无法列出了。 12'abc&amp;mno&amp;xyz'.match(/[a-z]+/g);// [&quot;abc&quot;, &quot;mno&quot;, &quot;xyz&quot;] replacereplace是String实例方法。 它的作用是将给定字符串替换匹配结果，并返回新的替换后的文本。源文本不会改变。 它接受两个参数。 第一个参数可以是字符串或者正则表达式，它的作用是匹配。 参数是字符串和参数是正则表达式的区别在于：正则表达式的表达能力更强，而且可以全局匹配。因此参数是字符串的话只能进行一次替换。 123456'abc-xyz-abc'.replace('abc', 'biu');// &quot;biu-xyz-abc&quot;'abc-xyz-abc'.replace(/abc/, 'biu');// &quot;biu-xyz-abc&quot;'abc-xyz-abc'.replace(/abc/g, 'biu');// &quot;biu-xyz-biu&quot; 第二个参数可以是字符串或者函数，它的作用是替换。 第二个参数是字符串replace方法为第二个参数是字符串的方式提供了一些特殊的变量，能满足一般需求。 $数字代表相应顺序的捕获组。注意，虽然它是一个变量，但是不要写成模板字符串`${$1}biu`，replace内部逻辑会自动解析字符串，提取出变量。 12'@abc-xyz-$abc'.replace(/([^-]+)abc/g, '$1biu');// &quot;@biu-xyz-$biu&quot; $&amp;代表匹配结果。 12'@abc-xyz-$abc'.replace(/([^-]+)abc/g, '{$&amp;}');// &quot;{@abc}-xyz-{$abc}&quot; $`代表匹配结果左边的文本。 12'@abc-xyz-$abc'.replace(/([^-]+)abc/g, '{$`}');// &quot;{}-xyz-{@abc-xyz-}&quot; $'代表匹配结果右边的文本。 12'@abc-xyz-$abc'.replace(/([^-]+)abc/g, &quot;{$'}&quot;);// &quot;{-xyz-$abc}-xyz-{}&quot; 有些时候我要的是变量的符号本身，而不是它的变量值，怎么办？加一个$转义一下。 123456'@abc-xyz-$abc'.replace(/([^-]+)abc/g, '$$1biu');// &quot;$1biu-xyz-$1biu&quot;'@abc-xyz-$abc'.replace(/([^-]+)abc/g, '$biu');// &quot;$biu-xyz-$biu&quot;'@abc-xyz-$abc'.replace(/([^-]+)abc/g, '$$biu');// &quot;$biu-xyz-$biu&quot; 在不会造成误会的场景，一个$和两个$的效果都是一个$，因为另一个充当转义符号。会造成误会的场景，那就必须加$转义了。 第二个参数是函数字符串的变量毕竟只能引用，无法操作。与之相对，函数的表达能力就强多了。 函数的返回值就是要替换的内容。函数如果没有返回值，默认返回undefined，所以替换内容就是undefined。 函数的第一个参数，是匹配结果。 1234'abc-xyz-abc'.replace(/abc/g, (match) =&gt; `{${match}}`);// &quot;{abc}-xyz-{abc}&quot;'abc-xyz-abc'.replace(/abc/g, (match) =&gt; {});// &quot;undefined-xyz-undefined&quot; 如果有捕获组，函数的后顺位参数与捕获组一一对应。 12'@abc3-xyz-$abc5'.replace(/([^-]+)abc(\\d+)/g, (match, $1, $2) =&gt; `{${$1}${match}${$2}}`);// &quot;{@@abc33}-xyz-{$$abc55}&quot; 倒数第二个参数是匹配结果在文本中的位置。 12'@abc-xyz-$abc'.replace(/([^-]+)abc/g, (match, $1, index) =&gt; `{${match}是位置是${index}}`);// &quot;{@abc是位置是0}-xyz-{$abc是位置是9}&quot; 倒数第一个参数是源文本。 12'abc-xyz'.replace(/abc/g, (match, index, string) =&gt; `{{${match}}属于{${string}}}`);// &quot;{{abc}属于{abc-xyz}}-xyz&quot; replace方法最常用的地方是转义HTML标签。 12'&lt;p&gt;hello regex&lt;/p&gt;'.replace(/&lt;/g, '&amp;lt;').replace(/&gt;/g, '&amp;gt;');// &quot;&amp;lt;p&amp;gt;hello regex&amp;lt;/p&amp;gt;&quot; searchsearch是String实例方法。 它的作用是找出首次匹配项的索引。它的功能较单一，性能也更好。 它接受一个正则表达式作为唯一参数。与match一样，如果传入一个非正则表达式，它会调用new RegExp()将其转换成一个正则实例。 12345678910'abc-xyz-abc'.search(/xyz/);// 4'abc-xyz-abc'.search(/xyz/g);// 4'abc-xyz-abc'.search(/mno/);// -1'abc-xyz-abc'.search();// 0'abc-xyz-abc'.search(/abc/);// 0 因为只能返回首次匹配的位置，所以全局匹配对它无效。 如果匹配失败，返回-1。 splitsplit是String实例方法。 它的作用是根据传入的分隔符切割源文本。它返回一个由被切割单元组成的数组。 它接受两个参数。第一个参数可以是字符串或者正则表达式，它是分隔符；第二个参数可选，限制返回数组的最大长度。 1234567891011121314'abc-def_mno+xyz'.split();// [&quot;abc-def_mno+xyz&quot;]'abc-def_mno+xyz'.split('-_+');// [&quot;abc-def_mno+xyz&quot;]'abc-def_mno+xyz'.split('');// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;-&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;_&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;+&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]'abc-def_mno+xyz'.split(/[-_+]/);// [&quot;abc&quot;, &quot;def&quot;, &quot;mno&quot;, &quot;xyz&quot;]'abc-def_mno+xyz'.split(/[-_+]/g);// [&quot;abc&quot;, &quot;def&quot;, &quot;mno&quot;, &quot;xyz&quot;]'abc-def_mno+xyz'.split(/[-_+]/, 3);// [&quot;abc&quot;, &quot;def&quot;, &quot;mno&quot;]'abc-def_mno+xyz'.split(/[-_+]/, 5);// [&quot;abc&quot;, &quot;def&quot;, &quot;mno&quot;, &quot;xyz&quot;] 如果第一个参数传入的是空字符串，则会切割每一个字符串。 另外，因为split方法中的正则是用来匹配分隔符，所以全局匹配没有意义。 execexec是RegExp实例方法。 它的作用是根据参数返回匹配结果，与字符串方法match相似。 123456/xyz/.exec('abc-xyz-abc');// [&quot;xyz&quot;, index: 4, input: &quot;abc-xyz-abc&quot;, groups: undefined]/mno/.exec('abc-xyz-abc');// null/xyz/.exec();// null 小小的区别在于参数为空的情况：exec直接返回null；match返回一个空字符串数组。原因也很好理解，有鱼没有网，最坏也就是没有收成；有网没有鱼，那可是连奔头都没有了。 它们俩最大的区别在于全局匹配的场景。 全局匹配就意味着多次匹配，RegExp实例有一个lastIndex属性，每匹配一次，这个属性就会更新为下一次匹配开始的位置。exec就是根据这个属性来实现全局匹配的。 1234567891011121314151617const reg = /abc/g;reg.lastIndex// 0reg.exec('abc-xyz-abc');// [&quot;abc&quot;, index: 0, input: &quot;abc-xyz-abc&quot;, groups: undefined]reg.lastIndex// 3reg.exec('abc-xyz-abc');// [&quot;abc&quot;, index: 8, input: &quot;abc-xyz-abc&quot;, groups: undefined]reg.lastIndex// 11reg.exec('abc-xyz-abc');// nullreg.lastIndex// 0reg.exec('abc-xyz-abc');// [&quot;abc&quot;, index: 0, input: &quot;abc-xyz-abc&quot;, groups: undefined] 如果有多个匹配结果，多次执行就能获得所有的匹配结果。所以exec一般用在循环语句中。 有两点需要特别注意： 因为lastIndex会不断更新，最终又会归于0，所以这个匹配过程是可以无限重复的。 lastIndex属性是属于正则实例的。只有同一个实例的lastIndex才会不断更新。 知道第二点意味着什么吗？ 1234567/abc/g.exec('abc-xyz-abc');// [&quot;abc&quot;, index: 0, input: &quot;abc-xyz-abc&quot;, groups: undefined]/abc/g.exec('abc-xyz-abc');// [&quot;abc&quot;, index: 0, input: &quot;abc-xyz-abc&quot;, groups: undefined]/abc/g.exec('abc-xyz-abc');// [&quot;abc&quot;, index: 0, input: &quot;abc-xyz-abc&quot;, groups: undefined]// ... 如果不把正则提取出来，获得它的引用，exec方法就一直在原地打转，因为每次都是一个新的正则实例，每次lastIndex都要从0开始。 testtest是RegExp实例方法。 它的作用是找出源文本是否有匹配项，与字符串方法search相似。多用于表单验证中。 123456/abc/.test('abc-xyz-abc');// true/mno/.test('abc-xyz-abc');// false/abc/.test();// false test方法与search方法的区别主要体现在两点： search方法返回的是索引，test方法只返回布尔值。 因为是正则实例方法，全局匹配时也会更新正则实例的lastIndex属性，所以也可以多次执行。 1234567891011121314151617const reg = /abc/g;reg.lastIndex// 0reg.test('abc-xyz-abc');// truereg.lastIndex// 3reg.test('abc-xyz-abc');// truereg.lastIndex// 11reg.test('abc-xyz-abc');// falsereg.lastIndex// 0reg.test('abc-xyz-abc');// true 修改字符串方法的底层实现我们也看到了，一部分处理正则的方法定义在String实例上，一部分处理正则的方法定义在RegExp实例上。为了将处理正则的方法全部统一到RegExp实例上，ES2015修改了部分字符串方法的底层实现。 具体来说，ES2015为RegExp实例新增了四个方法，字符串方法match、replace、search、split内部调用已经改成了相应的RegExp实例方法。 1234RegExp.prototype[Symbol.match]RegExp.prototype[Symbol.replace]RegExp.prototype[Symbol.search]RegExp.prototype[Symbol.split] Symbol.match是什么？Symbol是新增的一种基础数据类型，它有11个内置的值，指向语言内部使用的方法。 RegExp.prototype[Symbol.match]在使用上和match相比，调用者和参数翻转一下就可以了。 1234'abc-mno-xyz'.match(/mno/);// [&quot;mno&quot;, index: 4, input: &quot;abc-mno-xyz&quot;, groups: undefined]/mno/[Symbol.match]('abc-mno-xyz');// [&quot;mno&quot;, index: 4, input: &quot;abc-mno-xyz&quot;, groups: undefined] 本文摘自 https://github.com/veedrin/horseshoe","link":"/2022/02/05/regex-method/"},{"title":"sketch中英文切换","text":"Sketch 54版本之后会强制使用Mac系统语言 使用Mac终端: 12defaults write com.bohemiancoding.sketch3 AppleLanguages '(en)'defaults write com.bohemiancoding.sketch3 AppleLanguages '(zh-CN)'","link":"/2021/02/20/sketch-toggle-language/"},{"title":"mac apache start, stop, restart","text":"123sudo apachectl startsudo apachectl stopsudo apachectl restart","link":"/2018/08/08/terminal-mac-apache/"},{"title":"Terminal 几个快捷键","text":"将光标移动到行首ctrl + a 将光标移动到行尾ctrl + e 清除屏幕ctrl + l 搜索以前使用命令ctrl + r 清除当前行ctrl + u 清除至当前行尾ctrl + k 单词为单位移动option + 方向键","link":"/2017/08/11/terminal-shortcuts/"},{"title":"CommandLineTools reinstall","text":"12345678xcode-select --print-path# in my case /Library/Developer/CommandLineTools# the next line deletes the path returned by the command abovesudo rm -rf $(xcode-select --print-path)# install them (again) if you don't get a default installation promptxcode-select --install","link":"/2021/08/11/terminal-xcode-select/"},{"title":"vagrant","text":"commond describe $ vagrant init # 初始化 $ vagrant up # 启动虚拟机 $ vagrant halt # 关闭虚拟机 $ vagrant reload # 重启虚拟机 $ vagrant ssh # SSH 至虚拟机 $ vagrant suspend # 挂起虚拟机 $ vagrant resume # 唤醒虚拟机 $ vagrant status # 查看虚拟机运行状态 $ vagrant destroy # 销毁当前虚拟机 $ vagrant exit 从ssh退出 cd /var/www/astellas/docroot/ &amp;&amp; drush cr 清理缓存 cd /var/www/astellas/ &amp;&amp; composer update 模块升级","link":"/2017/08/10/vagrant/"},{"title":"vim cheatsheet","text":"光标移动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647h 光标左移，同 &lt;Left&gt; 键j 光标下移，同 &lt;Down&gt; 键k 光标上移，同 &lt;Up&gt; 键l 光标右移，同 &lt;Right&gt; 键CTRL-F 下一页CTRL-B 上一页CTRL-U 上移半屏CTRL-D 下移半屏0 跳到行首（是数字零，不是字母O），效用等同于 &lt;Home&gt; 键^ 跳到从行首开始第一个非空白字符$ 跳到行尾，效用等同于 &lt;End&gt; 键gg 跳到第一行，效用等同于 CTRL+&lt;Home&gt;G 跳到最后一行，效用等同于 CTRL+&lt;End&gt;nG 跳到第n行，比如 10G 是移动到第十行:n 跳到第n行，比如 :10&lt;回车&gt; 是移动到第十行10% 移动到文件 10% 处15| 移动到当前行的 15列w 跳到下一个单词开头 (word: 标点或空格分隔的单词)W 跳到下一个单词开头 (WORD: 空格分隔的单词)e 跳到下一个单词尾部 (word: 标点或空格分隔的单词)E 跳到下一个单词尾部 (WORD: 空格分隔的单词)b 上一个单词头 (word: 标点或空格分隔的单词)B 上一个单词头 (WORD: 空格分隔的单词)ge 上一个单词尾) 向前移动一个句子（句号分隔）( 向后移动一个句子（句号分隔）} 向前移动一个段落（空行分隔）{ 向后移动一个段落（空行分隔）&lt;enter&gt; 移动到下一行首个非空字符+ 移动到下一行首个非空字符（同回车键）- 移动到上一行首个非空字符H 移动到屏幕上部M 移动到屏幕中部L 移动到屏幕下部fx 跳转到下一个为 x 的字符，2f/ 可以找到第二个斜杆Fx 跳转到上一个为 x 的字符tx 跳转到下一个为 x 的字符前Tx 跳转到上一个为 x 的字符前; 跳到下一个 f/t 搜索的结果, 跳到上一个 f/t 搜索的结果&lt;S-Left&gt; 按住 SHIFT 按左键，向左移动一个单词&lt;S-Right&gt; 按住 SHIFT 按右键，向右移动一个单词&lt;S-Up&gt; 按住 SHIFT 按上键，向上翻页&lt;S-Down&gt; 按住 SHIFT 按下键，向下翻页gm 移动到行中gj 光标下移一行（忽略自动换行）gk 光标上移一行（忽略自动换行） 插入模式：进入退出123456789i 在光标处进入插入模式I 在行首进入插入模式a 在光标后进入插入模式A 在行尾进入插入模式o 在下一行插入新行并进入插入模式O 在上一行插入新行并进入插入模式gi 进入到上一次插入模式的位置&lt;ESC&gt; 退出插入模式CTRL-[ 退出插入模式（同 ESC 等价，但更顺手） INSERT MODE - 由 i, I, a, A, o, O 等命令进入插入模式后1234567891011121314151617181920212223242526272829303132&lt;Up&gt; 光标向上移动&lt;Down&gt; 光标向下移动&lt;Left&gt; 光标向左移动&lt;Right&gt; 光标向右移动&lt;S-Left&gt; 按住 SHIFT 按左键，向左移动一个单词&lt;S-Right&gt; 按住 SHIFT 按右键，向右移动一个单词&lt;S-Up&gt; 按住 SHIFT 按上键，向上翻页&lt;S-Down&gt; 按住 SHIFT 按下键，向下翻页&lt;PageUp&gt; 上翻页&lt;PageDown&gt; 下翻页&lt;Delete&gt; 删除光标处字符&lt;BS&gt; Backspace 向后删除字符&lt;Home&gt; 光标跳转行首&lt;End&gt; 光标跳转行尾CTRL-W 向后删除单词CTRL-O 临时退出插入模式，执行单条命令又返回插入模式CTRL-\\ CTRL-O 临时退出插入模式（光标保持），执行单条命令又返回插入模式CTRL-R 0 插入寄存器（内部 0号剪贴板）内容，CTRL-R 后可跟寄存器名CTRL-R &quot; 插入匿名寄存器内容，相当于插入模式下 p粘贴CTRL-R = 插入表达式计算结果，等号后面跟表达式CTRL-R : 插入上一次命令行命令CTRL-R / 插入上一次搜索的关键字CTRL-F 自动缩进CTRL-U 删除当前行所有字符CTRL-V {char} 插入非数字的字面量CTRL-V {number} 插入三个数字代表的 ascii/unicode 字符CTRL-V 065 插入 10进制 ascii 字符（两数字） 065 即 A字符CTRL-V x41 插入 16进制 ascii 字符（三数字） x41 即 A字符CTRL-V o101 插入 8进制 ascii 字符（三数字） o101 即 A字符CTRL-V u1234 插入 16进制 unicode 字符（四数字）CTRL-V U12345678 插入 16进制 unicode 字符（八数字）CTRL-K {ch1} {ch2} 插入 digraph（见 :h digraph），快速输入日文或符号等 文本编辑1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768r 替换当前字符R 进入替换模式，直至 ESC 离开s 替换字符（删除光标处字符，并进入插入模式，前可接数量）S 替换行（删除当前行，并进入插入模式，前可接数量）cc 改写当前行（删除当前行并进入插入模式），同 Scw 改写光标开始处的当前单词ciw 改写光标所处的单词caw 改写光标所处的单词，并且包括前后空格（如果有的话）c0 改写到行首c^ 改写到行首（第一个非零字符）c$ 改写到行末C 改写到行尾（同c$）ci&quot; 改写双引号中的内容ci' 改写单引号中的内容cib 改写小括号中的内容cab 改写小括号中的内容（包含小括号本身）ci) 改写小括号中的内容ci] 改写中括号中内容ciB 改写大括号中内容caB 改写大括号中的内容（包含大括号本身）ci} 改写大括号中内容cit 改写 xml tag 中的内容cis 改写当前句子c2w 改写下两个单词ct( 改写到小括号前x 删除当前字符，前面可以接数字，3x代表删除三个字符X 向前删除字符dd 删除当前行d0 删除到行首d^ 删除到行首（第一个非零字符）d$ 删除到行末D 删除到行末（同 d$）dw 删除当前单词diw 删除光标所处的单词daw 删除光标所处的单词，并包含前后空格（如果有的话）di&quot; 删除双引号中的内容di' 删除单引号中的内容dib 删除小括号中的内容di) 删除小括号中的内容dab 删除小括号内的内容（包含小括号本身）di] 删除中括号中内容diB 删除大括号中内容di} 删除大括号中内容daB 删除大括号内的内容（包含大括号本身）dit 删除 xml tag 中的内容dis 删除当前句子d2w 删除下两个单词dt( 删除到小括号前dgg 删除到文件头部dG 删除到文件尾部d} 删除下一段d{ 删除上一段u 撤销U 撤销整行操作CTRL-R 撤销上一次 u 命令J 链接多行为一行. 重复上一次操作~ 替换大小写g~iw 替换当前单词的大小写gUiw 将单词转成大写guiw 将当前单词转成小写guu 全行转为小写gUU 全行转为大写&lt;&lt; 减少缩进&gt;&gt; 增加缩进== 自动缩进CTRL-A 增加数字CTRL-X 减少数字 复制粘贴1234567891011121314151617181920212223242526272829303132333435363738p 粘贴到光标后P 粘贴到光标前v 开始标记y 复制标记内容V 开始按行标记CTRL-V 开始列标记y$ 复制当前位置到本行结束的内容yy 复制当前行Y 复制当前行，同 yyyiw 复制当前单词3yy 复制光标下三行内容v0 选中当前位置到行首v$ 选中当前位置到行末viw 选中当前单词vib 选中小括号内的东西vi) 选中小括号内的东西vi] 选中中括号内的东西viB 选中大括号内的东西vi} 选中大括号内的东西vis 选中句子中的东西vab 选中小括号内的东西（包含小括号本身）va) 选中小括号内的东西（包含小括号本身）va] 选中中括号内的东西（包含中括号本身）vaB 选中大括号内的东西（包含大括号本身）va} 选中大括号内的东西（包含大括号本身）gv 重新选择上一次选中的文字:set paste 允许粘贴模式（避免粘贴时自动缩进影响格式）:set nopaste 禁止粘贴模式&quot;?yy 复制当前行到寄存器 ? ，问号代表 0-9 的寄存器名称&quot;?d3j 删除光标下三行内容，并放到寄存器 ? ，问号代表 0-9 的寄存器名称&quot;?p 将寄存器 ? 的内容粘贴到光标后&quot;?P 将寄存器 ? 的内容粘贴到光标前:registers 显示所有寄存器内容:[range]y 复制范围，比如 :20,30y 是复制20到30行，:10y 是复制第十行:[range]d 删除范围，比如 :20,30d 是删除20到30行，:10d 是删除第十行ddp 交换两行内容：先删除当前行复制到寄存器，并粘贴&quot;_[command] 使用[command]删除内容，并且不进行复制（不会污染寄存器）&quot;*[command] 使用[command]复制内容到系统剪贴板（需要vim版本有clipboard支持） 文本对象 - c,d,v,y 等命令后接文本对象，一般为：&lt;范围 i/a&gt;&lt;类型&gt;12345678910111213141516171819202122232425262728$ 到行末0 到行首^ 到行首非空字符tx 光标位置到字符 x 之前fx 光标位置到字符 x 之处iw 整个单词（不包括分隔符）aw 整个单词（包括分隔符）iW 整个 WORD（不包括分隔符）aW 整个 WORD（包括分隔符）is 整个句子（不包括分隔符）ib 小括号内ab 小括号内（包含小括号本身）iB 大括号内aB 大括号内（包含大括号本身）i) 小括号内a) 小括号内（包含小括号本身）i] 中括号内a] 中括号内（包含中括号本身）i} 大括号内a} 大括号内（包含大括号本身）i' 单引号内a' 单引号内（包含单引号本身）i&quot; 双引号内a&quot; 双引号内（包含双引号本身）2i) 往外两层小括号内2a) 往外两层小括号内（包含小括号本身）2f) 到第二个小括号处2t) 到第二个小括号前 查找替换123456789101112/pattern 从光标处向文件尾搜索 pattern?pattern 从光标处向文件头搜索 patternn 向同一方向执行上一次搜索N 向相反方向执行上一次搜索* 向前搜索光标下的单词# 向后搜索光标下的单词:s/p1/p2/g 将当前行中全替换p1为p2:%s/p1/p2/g 将当前文件中全替换p1为p2:%s/p1/p2/gc 将当前文件中全替换p1为p2，并且每处询问你是否替换:10,20s/p1/p2/g 将第10到20行中所有p1替换为p2:%s/1\\\\2\\/3/123/g 将“1\\2/3” 替换为 “123”（特殊字符使用反斜杠标注）:%s/\\r//g 删除 DOS 换行符 ^M VISUAL MODE - 由 v, V, CTRL-V 进入的可视模式1234567891011121314&gt; 增加缩进&lt; 减少缩进d 删除高亮选中的文字x 删除高亮选中的文字c 改写文字，即删除高亮选中的文字并进入插入模式s 改写文字，即删除高亮选中的文字并进入插入模式y 拷贝文字~ 转换大小写o 跳转到标记区的另外一端O 跳转到标记块的另外一端u 标记区转换为小写U 标记区转换为大写g CTRL-G 显示所选择区域的统计信息&lt;Esc&gt; 退出可视模式 位置跳转1234567891011121314151617181920212223CTRL-O 跳转到上一个位置CTRL-I 跳转到下一个位置CTRL-^ 跳转到 alternate file (当前窗口的上一个文件）% 跳转到 {} () [] 的匹配gd 跳转到局部定义（光标下的单词的定义）gD 跳转到全局定义（光标下的单词的定义）gf 打开名称为光标下文件名的文件[[ 跳转到上一个顶层函数（比如C语言以大括号分隔）]] 跳转到下一个顶层函数（比如C语言以大括号分隔）[m 跳转到上一个成员函数]m 跳转到下一个成员函数[{ 跳转到上一处未匹配的 {]} 跳转到下一处未匹配的 }[( 跳转到上一处未匹配的 (]) 跳转到下一处未匹配的 )[c 上一个不同处（diff时）]c 下一个不同处（diff时）[/ 跳转到 C注释开头]/ 跳转到 C注释结尾`` 回到上次跳转的位置'' 回到上次跳转的位置`. 回到上次编辑的位置'. 回到上次编辑的位置 文件操作12345678910111213141516:w 保存文件:w &lt;filename&gt; 按名称保存文件:e &lt;filename&gt; 打开文件并编辑:saveas &lt;filename&gt; 另存为文件:r &lt;filename&gt; 读取文件并将内容插入到光标后:r !dir 将 dir 命令的输出捕获并插入到光标后:close 关闭文件:q 退出:q! 强制退出:wa 保存所有文件:cd &lt;path&gt; 切换 Vim 当前路径:pwd 显示 Vim 当前路径:new 打开一个新的窗口编辑新文件:enew 在当前窗口创建新文件:vnew 在左右切分的新窗口中编辑新文件:tabnew 在新的标签页中编辑新文件 已打开文件操作12345678910:ls 查案缓存列表:bn 切换到下一个缓存:bp 切换到上一个缓存:bd 删除缓存:b 1 切换到1号缓存:b abc 切换到文件名为 abc 开头的缓存:badd &lt;filename&gt; 将文件添加到缓存列表:set hidden 设置隐藏模式（未保存的缓存可以被切换走，或者关闭）:set nohidden 关闭隐藏模式（未保存的缓存不能被切换走，或者关闭）n CTRL-^ 切换缓存，先输入数字的缓存编号，再按 CTRL + 6 窗口操作12345678910111213141516171819202122232425262728293031:sp &lt;filename&gt; 上下切分窗口并在新窗口打开文件 filename:vs &lt;filename&gt; 左右切分窗口并在新窗口打开文件 filenameCTRL-W s 上下切分窗口CTRL-W v 左右切分窗口CTRL-W w 循环切换到下一个窗口CTRL-W W 循环切换到上一个窗口CTRL-W p 跳到上一个访问过的窗口CTRL-W c 关闭当前窗口CTRL-W o 关闭其他窗口CTRL-W h 跳到左边的窗口CTRL-W j 跳到下边的窗口CTRL-W k 跳到上边的窗口CTRL-W l 跳到右边的窗口CTRL-W + 增加当前窗口的行高，前面可以加数字CTRL-W - 减少当前窗口的行高，前面可以加数字CTRL-W &lt; 减少当前窗口的列宽，前面可以加数字CTRL-W &gt; 增加当前窗口的列宽，前面可以加数字CTRL-W = 让所有窗口宽高相同CTRL-W H 将当前窗口移动到最左边CTRL-W J 将当前窗口移动到最下边CTRL-W K 将当前窗口移动到最上边CTRL-W L 将当前窗口移动到最右边CTRL-W x 交换窗口CTRL-W f 在新窗口中打开名为光标下文件名的文件CTRL-W gf 在新标签页中打开名为光标下文件名的文件CTRL-W R 旋转窗口CTRL-W T 将当前窗口移到新的标签页中CTRL-W P 跳转到预览窗口CTRL-W z 关闭预览窗口CTRL-W _ 纵向最大化当前窗口CTRL-W | 横向最大化当前窗口 标签页123456789101112131415161718:tabs 显示所有标签页:tabe &lt;filename&gt; 在新标签页中打开文件 filename:tabn 下一个标签页:tabp 上一个标签页:tabc 关闭当前标签页:tabo 关闭其他标签页:tabn n 切换到第n个标签页，比如 :tabn 3 切换到第三个标签页:tabm n 标签移动:tabfirst 切换到第一个标签页:tablast 切换到最后一个标签页:tab help 在标签页打开帮助:tab drop &lt;file&gt; 如果文件已被其他标签页和窗口打开则跳过去，否则新标签打开:tab split 在新的标签页中打开当前窗口里的文件:tab ball 将缓存中所有文件用标签页打开:set showtabline=? 设置为 0 就不显示标签页标签，1会按需显示，2会永久显示ngt 切换到第n个标签页，比如 2gt 将会切换到第二个标签页gt 下一个标签页gT 上一个标签页 书签12345678910:marks 显示所有书签ma 保存当前位置到书签 a ，书签名小写字母为文件内，大写全局'a 跳转到书签 a所在的行`a 跳转到书签 a所在位置`. 跳转到上一次编辑的行'A 跳转到全文书签 A[' 跳转到上一个书签]' 跳转到下一个书签'&lt; 跳到上次可视模式选择区域的开始'&gt; 跳到上次可视模式选择区域的结束 常用设置1234567891011121314151617181920212223242526:set nocompatible 设置不兼容原始 vi 模式（必须设置在最开头）:set bs=? 设置BS键模式，现代编辑器为 :set bs=eol,start,indent:set sw=4 设置缩进宽度为 4:set ts=4 设置制表符宽度为 4:set noet 设置不展开 tab 成空格:set et 设置展开 tab 成空格:set winaltkeys=no 设置 GVim 下正常捕获 ALT 键:set nowrap 关闭自动换行:set ttimeout 允许终端按键检测超时（终端下功能键为一串ESC开头的扫描码）:set ttm=100 设置终端按键检测超时为100毫秒:set term=? 设置终端类型，比如常见的 xterm:set ignorecase 设置搜索是否忽略大小写:set smartcase 智能大小写，默认忽略大小写，除非搜索内容里包含大写字母:set list 设置显示制表符和换行符:set number 设置显示行号，禁止显示行号可以用 :set nonumber:set relativenumber 设置显示相对行号（其他行与当前行的距离）:set paste 进入粘贴模式（粘贴时禁用缩进等影响格式的东西）:set nopaste 结束粘贴模式:set spell 允许拼写检查:set hlsearch 设置高亮查找:set ruler 总是显示光标位置:set incsearch 查找输入时动态增量显示查找结果:set insertmode Vim 始终处于插入模式下，使用 ctrl-o 临时执行命令:set all 列出所有选项设置情况:syntax on 允许语法高亮:syntax off 禁止语法高亮 帮助信息12345678910111213141516171819:h tutor 入门文档:h quickref 快速帮助:h index 查询 Vim 所有键盘命令定义:h summary 帮助你更好的使用内置帮助系统:h CTRL-H 查询普通模式下 CTRL-H 是干什么的:h i_CTRL-H 查询插入模式下 CTRL-H 是干什么的:h i_&lt;Up&gt; 查询插入模式下方向键上是干什么的:h pattern.txt 正则表达式帮助:h eval 脚本编写帮助:h function-list 查看 VimScript 的函数列表 :h windows.txt 窗口使用帮助:h tabpage.txt 标签页使用帮助:h +timers 显示对 +timers 特性的帮助:h :! 查看如何运行外部命令:h tips 查看 Vim 内置的常用技巧文档:h set-termcap 查看如何设置按键扫描码:viusage NORMAL 模式帮助:exusage EX 命令帮助:version 显示当前 Vim 的版本号和特性 外部命令1234567:!ls 运行外部命令 ls，并等待返回:r !ls 将外部命令 ls 的输出捕获，并插入到光标后:w !sudo tee % sudo以后保存当前文件:call system('ls') 调用 ls 命令，但是不显示返回内容:!start notepad Windows 下启动 notepad，最前面可以加 silent:sil !start cmd Windows 下当前目录打开 cmd:%!prog 运行文字过滤程序，如整理 json格式 :%!python -m json.tool Quickfix 窗口12345678:copen 打开 quickfix 窗口（查看编译，grep等信息）:copen 10 打开 quickfix 窗口，并且设置高度为 10:cclose 关闭 quickfix 窗口:cfirst 跳到 quickfix 中第一个错误信息:clast 跳到 quickfix 中最后一条错误信息:cc [nr] 查看错误 [nr]:cnext 跳到 quickfix 中下一个错误信息:cprev 跳到 quickfix 中上一个错误信息 拼写检查1234567:set spell 打开拼写检查:set nospell 关闭拼写检查]s 下一处错误拼写的单词[s 上一处错误拼写的单词zg 加入单词到拼写词表中zug 撤销上一次加入的单词z= 拼写建议 代码折叠123456789101112131415161718za 切换折叠zA 递归切换折叠zc 折叠光标下代码zC 折叠光标下所有代码zd 删除光标下折叠zD 递归删除所有折叠zE 删除所有折叠zf 创建代码折叠zF 指定行数创建折叠zi 切换折叠zm 所有代码折叠一层zr 所有代码打开一层zM 折叠所有代码，设置 foldlevel=0，设置 foldenablezR 打开所有代码，设置 foldlevel 为最大值zn 折叠 none，重置 foldenable 并打开所有代码zN 折叠 normal，重置 foldenable 并恢复所有折叠zo 打开一层代码zO 打开光标下所有代码折叠 宏录制12345qa 开始录制名字为 a 的宏q 结束录制宏@a 播放名字为 a 的宏@@ 播放上一个宏@: 重复上一个ex命令（即冒号命令） 其他命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546CTRL-X CTRL-F 插入模式下文件路径补全CTRL-X CTRL-O 插入下 Omnifunc 补全CTRL-X CTRL-N 插入模式下关键字补全CTRL-X CTRL-E 插入模式下向上滚屏CTRL-X CTRL-Y 插入模式下向下滚屏CTRL-E 向上滚屏CTRL-Y 向下滚屏CTRL-G 显示正在编辑的文件名，以及大小和位置信息g CTRL-G 显示文件的：大小，字符数，单词数和行数，可视模式下也可用zz 调整光标所在行到屏幕中央zt 调整光标所在行到屏幕上部zb 调整光标所在行到屏幕下部ga 显示光标下字符的 ascii 码或者 unicode 编码g8 显示光标下字符的 utf-8 编码字节序gi 回到上次进入插入的地方，并切换到插入模式K 查询光标下单词的帮助ZZ 保存文件（如果有改动的话），并关闭窗口ZQ 不保存文件关闭窗口CTRL-PgUp 上个标签页，GVim OK，部分终端软件需设置对应键盘码CTRL-PgDown 下个标签页，GVim OK，部分终端软件需设置对应键盘码CTRL-R CTRL-W 命令模式下插入光标下单词CTRL-INSERT 复制到系统剪贴板（GVIM）SHIFT-INSERT 粘贴系统剪贴板的内容（GVIM）:set ff=unix 设置换行为 unix:set ff=dos 设置换行为 dos:set ff? 查看换行设置:set nohl 清除搜索高亮:set termcap 查看会从终端接收什么以及会发送给终端什么命令:set guicursor= 解决 SecureCRT/PenguiNet 中 NeoVim 局部奇怪字符问题:set t_RS= t_SH= 解决 SecureCRT/PenguiNet 中 Vim8.0 终端功能奇怪字符:set fo+=a 开启文本段的实时自动格式化:earlier 15m 回退到15分钟前的文件内容:.!date 在当前窗口插入时间:%!xxd 开始二进制编辑:%!xxd -r 保存二进制编辑:r !curl -sL {URL} 读取 url 内容添加到光标后:g/^\\s*$/d 删除空行:g/green/d 删除所有包含 green 的行:v/green/d 删除所有不包含 green 的行:g/gladiolli/# 搜索单词打印结果，并在结果前加上行号:g/ab.*cd.*efg/# 搜索包含 ab,cd 和 efg 的行，打印结果以及行号:v/./,/./-j 压缩空行:Man bash 在 Vim 中查看 man，先调用 :runtime! ftplugin/man.vim 激活/fred\\|joe 搜索 fred 或者 joe/\\&lt;\\d\\d\\d\\d\\&gt; 精确搜索四个数字/^\\n\\{3} 搜索连续三个空行 Plugin - https://github.com/tpope/vim-commentary12345gcc 注释当前行gc{motion} 注释 {motion} 所标注的区域，比如 gcap 注释整段gci{ 注释大括号内的内容gc 在 Visual Mode 下面按 gc 注释选中区域:7,17Commentary 注释 7 到 17 行 Plugin - https://github.com/junegunn/vim-easy-align12:EasyAlign = 以第一个匹配的=为中心对齐:EasyAlign *= 匹配并且对齐所有= Plugin - https://github.com/tpope/vim-unimpaired123456789101112131415161718192021222324252627[space 向上插入空行]space 向下插入空行[e 替换当前行和上一行]e 替换当前行和下一行[x XML 编码]x XML 解码[u URL 编码]u URL 解码[y C 字符串编码]y C 字符串解码[q 上一个 quickfix 错误]q 下一个 quickfix 错误[Q 第一个 quickfix 错误]Q 最后一个 quickfix 错误[f 切换同目录里上一个文件]f 切换同目录里下一个文件[os 设置 :set spell]os 设置 :set nospell=os 设置 :set invspell[on 显示行号]on 关闭行号[ol 显示回车和制表符 :set list]ol 不显示回车和制表符 :set nolist[b 缓存切换到上一个文件，即 :bp]b 缓存切换到下一个文件，即 :bn[B 缓存切换到第一个文件，即 :bfirst]B 缓存切换到最后一个文件，即 :blast Plugin - https://github.com/skywind3000/asyncrun.vim12:AsyncRun ls 异步运行命令 ls 结果输出到 quickfix 使用 :copen 查看:AsyncRun -raw ls 异步运行命令 ls 结果不匹配 errorformat Plugin - https://github.com/gaving/vim-textobj-argument12345678cia 改写函数参数caa 改写函数参数（包括逗号分隔）dia 删除函数参数daa 删除函数参数（包括逗号分隔）via 选取函数参数vaa 选取函数参数（包括逗号分隔）yia 复制函数参数yaa 复制函数参数（包括逗号分隔） 网络资源12345678910111213最新版本 https://github.com/vim/vim Windows 最新版 https://github.com/vim/vim-win32-installer/releases插件浏览 http://vimawesome.comreddit https://www.reddit.com/r/vim/正确设置 ALT/BS 键 http://www.skywind.me/blog/archives/2021视频教程 http://vimcasts.org/中文帮助 http://vimcdoc.sourceforge.net/doc/help.html中文版入门到精通 https://github.com/wsdjeg/vim-galore-zh_cn五分钟脚本入门 http://www.skywind.me/blog/archives/2193脚本精通 http://learnvimscriptthehardway.stevelosh.com/中文脚本帮助 vimcdoc.sourceforge.net/doc/eval.html十六年使用经验 http://zzapper.co.uk/vimtips.html配色方案 http://vimcolors.com/ TIPS123456789101112131415161718192021- 永远不要用 CTRL-C 代替 &lt;ESC&gt; 完全不同的含义，容易错误中断运行的后台脚本- 很多人使用 CTRL-[ 代替 &lt;ESC&gt;，左手小指 CTRL，右手小指 [ 熟练后很方便- 某些终端中使用 Vim 8 内嵌终端如看到奇怪字符，使用 :set t_RS= t_SH= 解决- 某些终端中使用 NeoVim 如看到奇怪字符，使用 :set guicursor= 解决- 多使用 ciw, ci[, ci&quot;, ci( 以及 diw, di[, di&quot;, di( 命令来快速改写/删除文本- 在行内左右移动光标时，多使用w b e或W B E，而不是h l或方向键，这样会快很多- SHIFT 相当于移动加速键， w b e 移动光标很慢，但是 W B E 走的很快- 自己要善于总结新技巧，比如移动到行首非空字符时用 0w 命令比 ^ 命令更容易输入- 在空白行使用 dip 命令可以删除所有临近的空白行，viw 可以选择连续空白- 缩进时使用 &gt;8j &gt;} &lt;ap &gt;ap =i} == 会方便很多- 插入模式下，当你发现一个单词写错了，应该多用 CTRL-W 这比 &lt;BackSpace&gt; 快- y d c 命令可以很好结合 f t 和 /X 比如 dt) 和 y/end&lt;cr&gt;- c d x 命令会自动填充寄存器 &quot;1 到 &quot;9 , y 命令会自动填充 &quot;0 寄存器- 用 v 命令选择文本时，可以用 o 掉头选择，有时很有用- 写文章时，可以写一段代码块，然后选中后执行 :!python 代码块就会被替换成结果- 搜索后经常使用 :nohl 来消除高亮，使用很频繁，可以 map 到 &lt;BackSpace&gt; 上- 搜索时可以用 CTRL-R CTRL-W 插入光标下的单词，命令模式也能这么用- 映射按键时，应该默认使用 noremap ，只有特别需要的时候使用 map- 当你觉得做某事很低效时，你应该停下来，u u u u 然后思考正确的高效方式来完成- 用 y复制文本后，命令模式中 CTRL-R 然后按双引号 0 可以插入之前复制内容- Windows 下的 GVim 可以设置 set rop=type:directx,renmode:5 增强显示 References1234567891011https://github.com/groenewege/vimrc/blob/master/vim_cheat_sheet.txthttp://blog.g-design.net/post/4789778607/vim-cheat-sheethttp://www.keyxl.com/aaa8263/290/VIM-keyboard-shortcuts.htmhttp://jmcpherson.org/editing.htmlhttp://www.fprintf.net/vimCheatSheet.htmlhttp://www.ouyaoxiazai.com/article/24/654.htmlhttp://bbs.it-home.org/thread-80794-1-1.htmlhttp://www.lpfrx.com/wp-content/uploads/2008/09/vi.jpghttp://michael.peopleofhonoronly.com/vim/https://github.com/hobbestigrou/vimtips-fortune/blob/master/fortunes/vimtipshttps://github.com/glts/vim-cottidie/blob/master/autoload/cottidie/tips vim: set ts=4 sw=4 tw=0 noet noautoindent fdm=manual :","link":"/2020/08/13/vim-cheatsheet/"},{"title":"webpack4 基本设置应用示例 (Nodejs -v10)","text":"目录结构dist | font | | ... | images | | ... | js | | index.js | css | | styles.css node_modules src | font | | ... | images | | ... | js | | module | | | loading.js | | | ... | | index.js | scss | | base | | | ... | | function | | | ... | | layout | | | ... | | mixin | | | ... | | _variables.scss | | styles.scss package.json webpack.config.js webpack.config.entry.js（把需要编译的多个js入口单独写配置文件） 使用方法npm install 安装命令（每个项目仅需执行一次）npm run-script build 编译一次，并压缩文件npm start 编译并启动监听 package.json123456789101112131415161718192021222324252627282930{ &quot;name&quot;: &quot;front-env-webpack4&quot;, &quot;description&quot;: &quot;&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;private&quot;: true, &quot;license&quot;: &quot;ISC&quot;, &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack -p --progress --mode production&quot;, &quot;start&quot;: &quot;webpack -w --progress --mode development&quot; }, &quot;devDependencies&quot;: { &quot;ajv&quot;: &quot;^6.5.2&quot;, &quot;babel-core&quot;: &quot;^6.26.3&quot;, &quot;babel-loader&quot;: &quot;^7.1.5&quot;, &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;, &quot;css-loader&quot;: &quot;^1.0.0&quot;, &quot;extract-text-webpack-plugin&quot;: &quot;^4.0.0-beta.0&quot;, &quot;file-loader&quot;: &quot;^1.1.11&quot;, &quot;node-sass&quot;: &quot;^4.9.2&quot;, &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^5.0.0&quot;, &quot;postcss-loader&quot;: &quot;^2.1.6&quot;, &quot;sass-loader&quot;: &quot;^7.0.3&quot;, &quot;style-loader&quot;: &quot;^0.21.0&quot;, &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.2.7&quot;, &quot;webpack&quot;: &quot;^4.16.1&quot;, &quot;webpack-cli&quot;: &quot;^3.0.8&quot; }, &quot;dependencies&quot;: {}} webpack.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var path = require('path')var ExtractTextPlugin = require('extract-text-webpack-plugin')module.exports = { entry: './src/js/index.js', // entry: require('./webpack.config.entry'), output: { path: path.resolve(__dirname, 'dist'), filename: 'js/index.js' // filename: 'js/[name].js' }, resolve: { extensions: ['*', '.js'] }, module: { rules: [ { test: /\\.js?$/, include: path.resolve(__dirname, 'src/js'), use: [ { loader: 'babel-loader', options: { presets: ['env'] } } ] }, { test: /\\.(scss|css)$/, loader: ExtractTextPlugin.extract({ fallback: 'style-loader', publicPath: '../', use: [ { loader: 'css-loader', options: { minimize: true } }, { loader: 'sass-loader' }, { loader: 'postcss-loader', options: { options: {} } } ] }) }, { test: /\\.(svg|png|jpe?g)(\\?\\S*)?$/, use: [ { loader: 'file-loader?name=images/[name].[ext]' } ] }, { test: /\\.(eot|svg|ttf|woff|woff2)$/, exclude: [/images/], use: [ { loader: 'file-loader?name=fonts/[name].[ext]' } ] } ] }, plugins: [ new ExtractTextPlugin('css/styles.css') // new ExtractTextPlugin('css/[name].css') ]} webpack.config.entry.js1234567var path = require('path');module.exports = { 'index': path.resolve(__dirname, './src/js/index.js'), // ...} index.js12345678910require('./../scss/style.scss'); // modify the style.scssimport { loading } from './module/loading';window.onload = function () { // loading loading();}; loading.js1234567891011121314151617export let loading = () =&gt; { (function ($) { 'use strict'; let loadingHTML = `&lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;`; $(document).ajaxStart(function() { $('body').append(loadingHTML); }) $(document).ajaxStop(function() { $('.loading').remove(); }) })(jQuery);}","link":"/2018/05/31/webpack-basic-applications/"}],"tags":[{"name":"css","slug":"css","link":"/tags/css/"},{"name":"sass","slug":"sass","link":"/tags/sass/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"ios","slug":"ios","link":"/tags/ios/"},{"name":"retina","slug":"retina","link":"/tags/retina/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"brew","slug":"brew","link":"/tags/brew/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"meta","slug":"meta","link":"/tags/meta/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"wechat","slug":"wechat","link":"/tags/wechat/"},{"name":"zepto","slug":"zepto","link":"/tags/zepto/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"cli","slug":"cli","link":"/tags/cli/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"regex","slug":"regex","link":"/tags/regex/"},{"name":"sketch","slug":"sketch","link":"/tags/sketch/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"vagrant","slug":"vagrant","link":"/tags/vagrant/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"}],"categories":[{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"Manual","slug":"Manual","link":"/categories/Manual/"},{"name":"Util","slug":"Util","link":"/categories/Util/"}],"pages":[{"title":"标签","text":"","link":"/tags/index.html"}]}