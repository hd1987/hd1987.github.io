<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Regular Expressions 正则表达式语法 - AdiHuang</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="AdiHuang"><meta name="msapplication-TileImage" content="/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="AdiHuang"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="普通字符什么叫普通字符？ 当我们写a的时候，我们指的就是a；当我们写爱的时候，我们指的就是爱。 &amp;amp;#x27;hello 😀 regex&amp;amp;#x27;.match(&amp;#x2F;😀&amp;#x2F;);&amp;#x2F;&amp;#x2F; [&amp;quot;😀&amp;quot;, index: 6, input: &amp;quot;hello 😀 regex&amp;quot;, groups: undefined]"><meta property="og:type" content="blog"><meta property="og:title" content="Regular Expressions 正则表达式语法"><meta property="og:url" content="http://blog.adihuang.com/2022/02/05/regex-grammar/"><meta property="og:site_name" content="AdiHuang"><meta property="og:description" content="普通字符什么叫普通字符？ 当我们写a的时候，我们指的就是a；当我们写爱的时候，我们指的就是爱。 &amp;amp;#x27;hello 😀 regex&amp;amp;#x27;.match(&amp;#x2F;😀&amp;#x2F;);&amp;#x2F;&amp;#x2F; [&amp;quot;😀&amp;quot;, index: 6, input: &amp;quot;hello 😀 regex&amp;quot;, groups: undefined]"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://blog.adihuang.com/img/og_image.png"><meta property="article:published_time" content="2022-02-05T07:34:23.000Z"><meta property="article:modified_time" content="2024-01-09T06:09:34.405Z"><meta property="article:author" content="AdiHuang"><meta property="article:tag" content="regex"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://blog.adihuang.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.adihuang.com/2022/02/05/regex-grammar/"},"headline":"Regular Expressions 正则表达式语法","image":["http://blog.adihuang.com/img/og_image.png"],"datePublished":"2022-02-05T07:34:23.000Z","dateModified":"2024-01-09T06:09:34.405Z","author":{"@type":"Person","name":"AdiHuang"},"publisher":{"@type":"Organization","name":"AdiHuang","logo":{"@type":"ImageObject","url":"http://blog.adihuang.com/logo.svg"}},"description":"普通字符什么叫普通字符？ 当我们写a的时候，我们指的就是a；当我们写爱的时候，我们指的就是爱。 &amp;#x27;hello 😀 regex&amp;#x27;.match(&#x2F;😀&#x2F;);&#x2F;&#x2F; [&quot;😀&quot;, index: 6, input: &quot;hello 😀 regex&quot;, groups: undefined]"}</script><link rel="canonical" href="http://blog.adihuang.com/2022/02/05/regex-grammar/"><link rel="icon" href="/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/logo.svg" alt="AdiHuang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-02-05T07:34:23.000Z" title="2/5/2022, 7:34:23 AM">2022-02-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Manual/">Manual</a></span></div></div><h1 class="title is-3 is-size-4-mobile">Regular Expressions 正则表达式语法</h1><div class="content"><h2 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h2><p>什么叫普通字符？</p>
<p>当我们写<code>a</code>的时候，我们指的就是<code>a</code>；当我们写<code>爱</code>的时候，我们指的就是<code>爱</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;hello 😀 regex&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/😀/</span>);<br><span class="hljs-comment">// [&quot;😀&quot;, index: 6, input: &quot;hello 😀 regex&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<span id="more"></span>

<p>这就是普通字符，它在正则中的含义就是检索它本身。除了正则规定的部分字符外，其余的都是普通字符，包括各种人类语言，包括emoji，只要能够表达为字符串。</p>
<h2 id="开始与结束"><a href="#开始与结束" class="headerlink" title="开始与结束"></a>开始与结束</h2><p><code>^</code>字符的英文是<code>caret</code>，翻译成中文是<code>脱字符</code>。不要问我，又不是我翻译的。它在正则中属于元字符，通常代表的意义是文本的开始。说通常是因为当它在字符组中<code>[^abc]</code>另有含义。</p>
<p>什么叫文本的开始？就是如果它是正则主体的第一个符号，那紧跟着它的字符必须是被匹配文本的第一个字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;regex&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^r/</span>);<br><span class="hljs-comment">// [&quot;r&quot;, index: 0, input: &quot;regex&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>问题来了，如果<code>^</code>不是正则的第一个符号呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;regex&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/a^r/</span>);<br><span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure>

<p>所以呀，关于它有三点需要注意：</p>
<ul>
<li>作为匹配文本开始元字符的时候必须是正则主体的第一个符号，否则正则无效。</li>
<li>它匹配的是一个位置，而不是具体的文本。</li>
<li>它在其他规则中有另外的含义。</li>
</ul>
<p><code>$</code>字符与<code>^</code>正好相反。它代表文本的结束，并且没有其他含义(其实是有的，但不是在正则主体内)。同样，它必须是正则主体的最后一个符号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;regex&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/x$/</span>);<br><span class="hljs-comment">// [&quot;x&quot;, index: 4, input: &quot;regex&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p><code>^</code>与<code>$</code>特殊的地方在于它匹配的是一个位置。位置不像字符，它看不见，所以更不容易理解。</p>
<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>我们现在已经知道<code>$</code>匹配文本的结束位置，它是元字符。但是如果我想匹配<code>$</code>本身呢？匹配一个美元符号的需求再常见不过了吧。所以我们得将它贬为庶民。</p>
<p><code>\</code>反斜杠就是干这个的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;price: $3.6&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\$[0-9]+\.[0-9]+$/</span>);<br><span class="hljs-comment">// [&quot;$3.6&quot;, index: 7, input: &quot;price: $3.6&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>上面的例子有点超纲了，超纲的部分先不管。</p>
<p>你可以认为<code>\</code>也是一个元字符，它跟在另一个元字符后面，就能还原它本来的含义。</p>
<p>如果有两个<code>\</code>呢？那就是转义自身了。如果有三个<code>\</code>呢？我们得分成两段去理解。以此类推。</p>
<p>普通字符前面跟了一个<code>\</code>是什么效果？首先它们是一个整体，然后普通字符转义后还是普通字符。</p>
<h2 id="带反斜杠的元字符"><a href="#带反斜杠的元字符" class="headerlink" title="带反斜杠的元字符"></a>带反斜杠的元字符</h2><p>一般来说，普通字符前面带反斜杠还是普通字符，但是有一些普通字符，带反斜杠后反而变成了元字符。</p>
<p>要怪只能怪计算机领域的常用符号太少了。</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\b</td>
<td>匹配一个单词边界(boundary)</td>
</tr>
<tr>
<td>\B</td>
<td>匹配一个非单词边界</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符(digit)</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符</td>
</tr>
<tr>
<td>\s</td>
<td>匹配一个空白字符(space)</td>
</tr>
<tr>
<td>\S</td>
<td>匹配一个非空白字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配一个字母或者一个数字或者一个下划线(word)</td>
</tr>
<tr>
<td>\W</td>
<td>匹配一个字母、数字和下划线之外的字符</td>
</tr>
</tbody></table>
<p>你这么聪明，肯定一眼就看出来，大写代表反义。对，就是这么好记。</p>
<h3 id="b元字符"><a href="#b元字符" class="headerlink" title="\b元字符"></a>\b元字符</h3><p><code>\b</code>匹配的也是一个位置，而不是一个字符。单词和空格之间的位置，就是所谓单词边界。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;hello regex&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\bregex$/</span>);<br><span class="hljs-comment">// [&quot;regex&quot;, index: 6, input: &quot;hello regex&quot;, groups: undefined]</span><br><span class="hljs-string">&#x27;hello regex&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\Bregex$/</span>);<br><span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure>

<p>所谓单词边界，对中文等其他语言是无效的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;jiangshuying gaoyuanyuan huosiyan&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\bgaoyuanyuan\b/</span>);<br><span class="hljs-comment">// [&quot;gaoyuanyuan&quot;, index: 13, input: &quot;jiangshuying gaoyuanyuan huosiyan&quot;, groups: undefined]</span><br><span class="hljs-string">&#x27;江疏影 高圆圆 霍思燕&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\b高圆圆\b/</span>);<br><span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure>

<p>所以<code>\b</code>翻译一下就是<code>^\w|\w$|\W\w|\w\W</code>。</p>
<h3 id="d元字符"><a href="#d元字符" class="headerlink" title="\d元字符"></a>\d元字符</h3><p><code>\d</code>匹配一个数字，注意，这里的数字不是指JavaScript中的数字类型，因为文本全是字符串。它指的是代表数字的字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;123&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d/</span>);<br><span class="hljs-comment">// [&quot;1&quot;, index: 0, input: &quot;123&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<h3 id="s元字符"><a href="#s元字符" class="headerlink" title="\s元字符"></a>\s元字符</h3><p><code>\s</code>匹配一个空白字符。</p>
<p>这里需要解释一下什么是空白字符。</p>
<p>空白字符不是空格，它是空格的超集。很多人说它是<code>\f\n\r\t\v</code>的总和，其中<code>\f</code>是换页符，<code>\n</code>是换行符，<code>\r</code>是回车符，<code>\t</code>是水平制表符，<code>\v</code>是垂直制表符。是这样么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a b&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\w\s\w/</span>);<br><span class="hljs-comment">// [&quot;a b&quot;, index: 0, input: &quot;a b&quot;, groups: undefined]</span><br><span class="hljs-string">&#x27;a b&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\w\f\w/</span>);<br><span class="hljs-comment">// null</span><br><span class="hljs-string">&#x27;a b&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\w\n\w/</span>);<br><span class="hljs-comment">// null</span><br><span class="hljs-string">&#x27;a b&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\w\r\w/</span>);<br><span class="hljs-comment">// null</span><br><span class="hljs-string">&#x27;a b&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\w\t\w/</span>);<br><span class="hljs-comment">// null</span><br><span class="hljs-string">&#x27;a b&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\w\v\w/</span>);<br><span class="hljs-comment">// null</span><br><span class="hljs-string">&#x27;a b&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\w \w/</span>);<br><span class="hljs-comment">// [&quot;a b&quot;, index: 0, input: &quot;a b&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>这样说的人，明显是没有做过实验。其实正确的写法是<code>空格\f\n\r\t\v</code>的总和，集合里面包含一个空格，可千万别忽略了。诶，难道空格在正则中的写法就是<code>空一格</code>么，是的，就是这样随意。</p>
<p>这个集合中很多都是不可打印字符，估计只有<code>\n</code>是我们的老朋友。所以，如果不需要区分空格和换行的话，那就大胆的用<code>\s</code>吧。</p>
<h3 id="w元字符"><a href="#w元字符" class="headerlink" title="\w元字符"></a>\w元字符</h3><p><code>\w</code>匹配一个字母或者一个数字或者一个下划线。为什么要将它们放一起？想一想JavaScript中的变量规则，包括很多应用的用户名都只能是这三样，所以把它们放一起挺方便的。</p>
<p>不过要注意，字母指的是26个英文字母，其他的不行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;正则&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\w/</span>);<br><span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure>

<h3 id="负阴抱阳"><a href="#负阴抱阳" class="headerlink" title="负阴抱阳"></a>负阴抱阳</h3><p>如果我们将大写和小写的带反斜杠的元字符组合在一起，就能匹配任何字符。是的，不针对任何人。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;@regex&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[\s\S]/</span>);<br><span class="hljs-comment">// [&quot;@&quot;, index: 0, input: &quot;@regex&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>方括号的含义我们先按下不表。</p>
<h2 id="道生一"><a href="#道生一" class="headerlink" title="道生一"></a>道生一</h2><p><code>.</code>在正则中的含义仙风道骨，它匹配换行符之外的任意单个字符。</p>
<p>如果文本不存在换行符，那么<code>.</code>和<code>[\b\B]</code>和<code>[\d\D]</code>和<code>[\s\S]</code>和<code>[\w\W]</code>是等价的。</p>
<p>如果文本存在换行符，那么<code>(.|\n)</code>和<code>[\b\B]</code>和<code>[\d\D]</code>和<code>[\s\S]</code>和<code>[\w\W]</code>是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;@regex&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/./</span>);<br><span class="hljs-comment">// [&quot;@&quot;, index: 0, input: &quot;@regex&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>前面我们一直在强调，一个元字符只匹配一个字符。即便强大如<code>.</code>它也只能匹配一个。</p>
<p>那匹配<code>gooooogle</code>的正则是不是得写成<code>/gooooogle/</code>呢？</p>
<p>正则冷笑，并向你发射一个蔑视。</p>
<p>如果匹配的模式有重复，我们可以声明它重复的次数。</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>?</td>
<td>重复零次或者一次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或者多次，也就是至少一次</td>
</tr>
<tr>
<td>*</td>
<td>重复零次或者多次，也就是任意次数</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或者更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n次到m次之间的次数，包含n次和m次</td>
</tr>
</tbody></table>
<p>有三点需要注意：</p>
<ul>
<li><p><code>?</code>在诸如匹配http协议的时候非常有用，就像这样：<code>/http(s)?/</code>。它在正则中除了是量词还有别的含义，后面会提到。</p>
</li>
<li><p>我们习惯用<code>/.*/</code>来匹配若干对我们没有价值的文本，它的含义是<code>若干除换行符之外的字符</code>。比如我们需要文本两头的格式化信息，中间是什么无所谓，它就派上用场了。不过它的性能可不好。</p>
</li>
<li><p><code>&#123;n,m&#125;</code>之间不能有空格，空格在正则中是有含义的。</p>
</li>
</ul>
<p>关于量词最令人困惑的是：它重复什么？</p>
<p>它重复紧贴在它前面的某个集合。第一点，必须是紧贴在它前面；第二点，重复一个集合。最常见的集合就是一个字符，当然正则中有一些元字符能够将若干字符变成一个集合，后面会讲到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;gooooogle&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/go&#123;2,5&#125;gle/</span>);<br><span class="hljs-comment">// [&quot;gooooogle&quot;, index: 0, input: &quot;gooooogle&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>如果一个量词紧贴在另一个量词后面会怎样？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;gooooogle&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/go&#123;2,5&#125;+gle/</span>);<br><span class="hljs-comment">// Uncaught SyntaxError: Invalid regular expression: /go&#123;2,5&#125;+gle/: Nothing to repeat</span><br></code></pre></td></tr></table></figure>

<h2 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h2><p>前面提到量词不能紧跟在另一个量词后面，马上要👋👋打脸了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;https&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/http(s)?/</span>);<br><span class="hljs-comment">// [&quot;https&quot;, &quot;s&quot;, index: 0, input: &quot;https&quot;, groups: undefined]</span><br><span class="hljs-string">&#x27;https&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/http(s)??/</span>);<br><span class="hljs-comment">// [&quot;http&quot;, undefined, index: 0, input: &quot;https&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>然而，我的脸是这么好打的？</p>
<p>紧跟在<code>?</code>后面的<code>?</code>它不是一个量词，而是一个模式切换符，从贪婪模式切换到非贪婪模式。</p>
<p>贪婪模式在正则中是默认的模式，就是在既定规则之下匹配尽可能多的文本。因为正则中有量词，它的重复次数可能是一个区间，这就有了取舍。</p>
<p>紧跟在量词之后加上<code>?</code>就可以开启非贪婪模式。怎么省事怎么来。</p>
<p>这里的要点是，<code>?</code>必须紧跟着量词，否则的话它自己就变成量词了。</p>
<h2 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h2><p>正则中的普通字符只能匹配它自己。如果我要匹配一个普通字符，但是我不确定它是什么，怎么办？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;grey or gray&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/gr[ae]y/</span>);<br><span class="hljs-comment">// [&quot;grey&quot;, index: 0, input: &quot;grey or gray&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>方括号在正则中表示一个区间，我们称它为字符组。</p>
<p>首先，字符组中的字符集合只是所有的可选项，最终它只能匹配一个字符。</p>
<p>然后，字符组是一个独立的世界，元字符不需要转义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;$&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[$&amp;@]/</span>);<br><span class="hljs-comment">// [&quot;$&quot;, index: 0, input: &quot;$&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>最后，有两个字符在字符组中有特殊含义。</p>
<p><code>^</code>在字符组中表示取反，不再是文本开始的位置了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;regex&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[^abc]/</span>);<br><span class="hljs-comment">// [&quot;r&quot;, index: 0, input: &quot;regex&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>如果我就要<code>^</code>呢？前面已经讲过了，转义。</p>
<p><code>-</code>本来是一个普通字符，在字符组中摇身一变成为连字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;13&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[1-9]3/</span>);<br><span class="hljs-comment">// [&quot;13&quot;, index: 0, input: &quot;13&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>连字符的意思是匹配范围在它的左边字符和右边字符之间。</p>
<p>如果我这样呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc-3&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[0-z]/</span>);<br><span class="hljs-comment">// [&quot;a&quot;, index: 0, input: &quot;abc-3&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;xyz-3&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[0-c]/</span>);<br><span class="hljs-comment">// [&quot;3&quot;, index: 4, input: &quot;xyz-3&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;xyz-3&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[0-$]/</span>);<br><span class="hljs-comment">// Uncaught SyntaxError: Invalid regular expression: /[0-$]/: Range out of order in character class</span><br></code></pre></td></tr></table></figure>

<p>发现什么了没有？只有两种字符是可以用连字符的：英文字母和数字。而且英文字母可以和数字连起来，英文字母的顺序在后面。这和扑克牌<code>1 2 3 4 5 6 7 8 9 10 J Q K</code>是一个道理。</p>
<h2 id="捕获组与非捕获组"><a href="#捕获组与非捕获组" class="headerlink" title="捕获组与非捕获组"></a>捕获组与非捕获组</h2><p>我们已经知道量词是怎么回事了，我们也知道量词只能重复紧贴在它前面的字符。</p>
<p>如果我要重复的是一串字符呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;i love you very very very much&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/i love you very +much/</span>);<br><span class="hljs-comment">// null</span><br><span class="hljs-string">&#x27;i love you very very very much&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/i love you v+e+r+y+ +much/</span>);<br><span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure>

<p>这样肯定是不行的。是时候请圆括号出山了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;i love you very very very much&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/i love you (very )+much/</span>);<br><span class="hljs-comment">// [&quot;i love you very very very much&quot;, &quot;very &quot;, index: 0, input: &quot;i love you very very very much&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>圆括号的意思是将它其中的字符集合打包成一个整体，然后量词就可以操作这个整体了。这和方括号的效果是完全不一样的。</p>
<p>而且默认的，圆括号的匹配结果是可以捕获的。</p>
<h3 id="正则内捕获"><a href="#正则内捕获" class="headerlink" title="正则内捕获"></a>正则内捕获</h3><p>现在我们有一个需求，匹配<code>&lt;div&gt;</code>标签。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;&lt;div&gt;hello regex&lt;/div&gt;&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/&lt;div&gt;.*&lt;\/div&gt;/</span>);<br><span class="hljs-comment">// [&quot;&lt;div&gt;hello regex&lt;/div&gt;&quot;, index: 0, input: &quot;&lt;div&gt;hello regex&lt;/div&gt;&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>这很简单。但如果我要匹配的是任意标签，包括自定义的标签呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;&lt;App&gt;hello regex&lt;/App&gt;&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/&lt;([a-zA-Z]+)&gt;.*&lt;\/\1&gt;/</span>);<br><span class="hljs-comment">// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, &quot;App&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>这时候就要用到正则的捕获特性。正则内捕获使用<code>\数字</code>的形式，分别对应前面的圆括号捕获的内容。这种捕获的引用也叫<strong>反向引用</strong>。</p>
<p>我们来看一个更复杂的情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/&lt;((A|a)pp)&gt;(hello regex)+&lt;\/\1&gt;&lt;p&gt;\2&lt;\/p&gt;&lt;p&gt;\3&lt;\/p&gt;/</span>);<br><span class="hljs-comment">// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&quot;, &quot;App&quot;, &quot;A&quot;, &quot;hello regex&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>如果有嵌套的圆括号，那么捕获的引用是先递归的，然后才是下一个顶级捕获。所谓深度优先。</p>
<h3 id="正则外捕获"><a href="#正则外捕获" class="headerlink" title="正则外捕获"></a>正则外捕获</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;@abc&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/@(abc)/</span>);<br><span class="hljs-comment">// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]</span><br><span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>;<br><span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></td></tr></table></figure>

<p>没错，<code>RegExp</code>就是构造正则的构造函数。如果有捕获组，它的实例属性<code>$数字</code>会显示对应的引用。</p>
<p>如果有多个正则呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;@abc&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/@(abc)/</span>);<br><span class="hljs-comment">// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]</span><br><span class="hljs-string">&#x27;@xyz&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/@(xyz)/</span>);<br><span class="hljs-comment">// [&quot;@xyz&quot;, &quot;xyz&quot;, index: 0, input: &quot;@xyz&quot;, groups: undefined]</span><br><span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>;<br><span class="hljs-comment">// &quot;xyz&quot;</span><br></code></pre></td></tr></table></figure>

<p><code>RegExp</code>构造函数的引用只显示最后一个正则的捕获。</p>
<p>另外还有一个字符串实例方法也支持正则捕获的引用，它就是<code>replace</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;hello **regex**&#x27;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\*&#123;2&#125;(.*)\*&#123;2&#125;/</span>, <span class="hljs-string">&#x27;&lt;strong&gt;$1&lt;/strong&gt;&#x27;</span>);<br><span class="hljs-comment">// &quot;hello &lt;strong&gt;regex&lt;/strong&gt;&quot;</span><br></code></pre></td></tr></table></figure>

<p>实际上它才是最常用的引用捕获的方式。</p>
<h3 id="捕获命名"><a href="#捕获命名" class="headerlink" title="捕获命名"></a>捕获命名</h3><blockquote>
<p>这是ES2018的新特性。</p>
</blockquote>
<p>使用<code>\数字</code>引用捕获必须保证捕获组的顺序不变。现在开发者可以给捕获组命名了，有了名字以后，引用起来更加确定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;&lt;App&gt;hello regex&lt;/App&gt;&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/&lt;(?&lt;tag&gt;[a-zA-Z]+)&gt;.*&lt;\/\k&lt;tag&gt;&gt;/</span>);<br><span class="hljs-comment">// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, &quot;App&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, groups: &#123;tag: &quot;App&quot;&#125;]</span><br></code></pre></td></tr></table></figure>

<p>在捕获组内部最前面加上<code>?&lt;key&gt;</code>，它就被命名了。使用<code>\k&lt;key&gt;</code>语法就可以引用已经命名的捕获组。</p>
<p>是不是很简单？</p>
<p>通常情况下，开发者只是想在正则中将某些字符当成一个整体看待。捕获组很棒，但是它做了额外的事情，肯定需要额外的内存占用和计算资源。于是正则又有了非捕获组的概念。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;@abc&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/@(abc)/</span>);<br><span class="hljs-comment">// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]</span><br><span class="hljs-string">&#x27;@abc&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/@(?:abc)/</span>);<br><span class="hljs-comment">// [&quot;@abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>只要在圆括号内最前面加上<code>?:</code>标识，就是告诉正则引擎：我只要这个整体，不需要它的引用，你就别费劲了。从上面的例子也可以看出来，<code>match</code>方法返回的结果有些许不一样。</p>
<p>个人观点：我觉得正则的捕获设计应该反过来，默认不捕获，加上<code>?:</code>标识后才捕获。因为大多数时候开发者是不需要捕获的，但是它又懒得加<code>?:</code>标识，会有些许性能浪费。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>有时候开发者需要在正则中使用<code>或者</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;高圆圆&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/陈乔恩|高圆圆/</span>);<br><span class="hljs-comment">// [&quot;高圆圆&quot;, index: 0, input: &quot;高圆圆&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p><code>|</code>就代表<code>或者</code>。字符组其实也是一个多选结构，但是它们俩有本质区别。字符组最终只能匹配一个字符，而分支匹配的是左边所有的字符或者右边所有的字符。</p>
<p>我们来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;我喜欢高圆圆&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/我喜欢陈乔恩|高圆圆/</span>);<br><span class="hljs-comment">// [&quot;高圆圆&quot;, index: 3, input: &quot;我喜欢高圆圆&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>因为<code>|</code>是将左右两边一切两半，然后匹配左边或者右边。所以上面的正则显然达不到我们想要的效果。这个时候就需要一个东西来缩小分支的范围。诶，你可能已经想到了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;我喜欢高圆圆&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/我喜欢(?:陈乔恩|高圆圆)/</span>);<br><span class="hljs-comment">// [&quot;我喜欢高圆圆&quot;, index: 0, input: &quot;我喜欢高圆圆&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>没错，就是圆括号。</p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>正则中有一些元字符，它不匹配字符，而是匹配一个位置。比如之前提到的<code>^</code>和<code>$</code>。<code>^</code>的意思是说这个位置应该是文本开始的位置。</p>
<p>正则还有一些比较高级的匹配位置的语法，它匹配的是：在这个位置之前或之后应该有什么内容。</p>
<p>零宽(zero-width)是什么意思？指的就是它匹配一个位置，本身没有宽度。</p>
<p>断言(assertion)是什么意思？指的是一种判断，断言之前或之后应该有什么或应该没有什么。</p>
<h3 id="零宽肯定先行断言"><a href="#零宽肯定先行断言" class="headerlink" title="零宽肯定先行断言"></a>零宽肯定先行断言</h3><p>所谓的肯定就是判断有什么，而不是判断没有什么。</p>
<p>而先行指的是向前看(lookahead)，断言的这个位置是为前面的规则服务的。</p>
<p>语法很简单：圆括号内最左边加上<code>?=</code>标识。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;CoffeeScript JavaScript javascript&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\b\w&#123;4&#125;(?=Script\b)/</span>);<br><span class="hljs-comment">// [&quot;Java&quot;, index: 13, input: &quot;CoffeeScript JavaScript javascript&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>上面匹配的是四个字母，这四个字母要满足以下条件：紧跟着的应该是<code>Script</code>字符串，而且<code>Script</code>字符串应该是单词的结尾部分。</p>
<p>所以，零宽肯定先行断言的意思是：现在有一段正则语法，用这段语法去匹配给定的文本。但是，满足条件的文本不仅要匹配这段语法，紧跟着它的必须是一个位置，这个位置又必须满足一段正则语法。</p>
<p>说的再直白点，我要匹配一段文本，但是这段文本后面必须紧跟着另一段特定的文本。零宽肯定先行断言就是一个界碑，我要满足前面和后面所有的条件，但是我只要前面的文本。</p>
<p>我们来看另一种情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;CoffeeScript JavaScript javascript&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\b\w&#123;4&#125;(?=Script\b)\w+/</span>);<br><span class="hljs-comment">// [&quot;JavaScript&quot;, index: 13, input: &quot;CoffeeScript JavaScript javascript&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>上面的例子更加直观，零宽肯定先行断言已经匹配过<code>Script</code>一次了，后面的<code>\w+</code>却还是能匹配<code>Script</code>成功，足以说明它的<code>零宽</code>特性。它为紧贴在它前面的规则服务，并且不影响后面的匹配规则。</p>
<h3 id="零宽肯定后行断言"><a href="#零宽肯定后行断言" class="headerlink" title="零宽肯定后行断言"></a>零宽肯定后行断言</h3><p>先行是向前看，那后行就是向后看(lookbehind)咯。</p>
<p>语法是圆括号内最左边加上<code>?&lt;=</code>标识。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;演员高圆圆 将军霍去病 演员霍思燕&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(?&lt;=演员)霍\S+/</span>);<br><span class="hljs-comment">// [&quot;霍思燕&quot;, index: 14, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>一个正则可以有多个断言：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;演员高圆圆 将军霍去病 演员霍思燕&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(?&lt;=演员)霍.+?(?=\s|$)/</span>);<br><span class="hljs-comment">// [&quot;霍思燕&quot;, index: 14, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<h3 id="零宽否定先行断言"><a href="#零宽否定先行断言" class="headerlink" title="零宽否定先行断言"></a>零宽否定先行断言</h3><p>肯定是判断有什么，否定就是判断没有什么咯。</p>
<p>语法是圆括号内最左边加上<code>?!</code>标识。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;TypeScript Perl JavaScript&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\b\w&#123;4&#125;(?!Script\b)/</span>);<br><span class="hljs-comment">// [&quot;Perl&quot;, index: 11, input: &quot;TypeScript Perl JavaScript&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<h3 id="零宽否定后行断言"><a href="#零宽否定后行断言" class="headerlink" title="零宽否定后行断言"></a>零宽否定后行断言</h3><p>语法是圆括号最左边加上<code>?&lt;!</code>标识。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;演员高圆圆 将军霍去病 演员霍思燕&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(?&lt;!演员)霍\S+/</span>);<br><span class="hljs-comment">// [&quot;霍去病&quot;, index: 8, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>正则表达式除了主体语法，还有若干可选的模式修饰符。</p>
<p>写法就是将修饰符安插在正则主体的尾巴上。比如这样：<code>/abc/gi</code>。</p>
<h3 id="g修饰符"><a href="#g修饰符" class="headerlink" title="g修饰符"></a>g修饰符</h3><p><code>g</code>是<code>global</code>的缩写。默认情况下，正则从左向右匹配，只要匹配到了结果就会收工。<code>g</code>修饰符会开启全局匹配模式，找到所有匹配的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;演员高圆圆 将军霍去病 演员霍思燕&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(?&lt;=演员)\S+/</span>);<br><span class="hljs-comment">// [&quot;高圆圆&quot;, index: 2, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]</span><br><span class="hljs-string">&#x27;演员高圆圆 将军霍去病 演员霍思燕&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(?&lt;=演员)\S+/g</span>);<br><span class="hljs-comment">// [&quot;高圆圆&quot;, &quot;霍思燕&quot;]</span><br></code></pre></td></tr></table></figure>

<h3 id="i修饰符"><a href="#i修饰符" class="headerlink" title="i修饰符"></a>i修饰符</h3><p><code>i</code>是<code>ignoreCase</code>的缩写。默认情况下，<code>/z/</code>是无法匹配<code>Z</code>的，所以我们有时候不得不这样写：<code>/[a-zA-Z]/</code>。<code>i</code>修饰符可以全局忽略大小写。</p>
<p>很多时候我们不在乎文本是大写、小写还是大小写混写，这个修饰符还是很有用的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;javascript is great&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/JavaScript/</span>);<br><span class="hljs-comment">// null</span><br><span class="hljs-string">&#x27;javascript is great&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/JavaScript/i</span>);<br><span class="hljs-comment">// [&quot;javascript&quot;, index: 0, input: &quot;javascript is great&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<h3 id="m修饰符"><a href="#m修饰符" class="headerlink" title="m修饰符"></a>m修饰符</h3><p><code>m</code>是<code>multiline</code>的缩写。这个修饰符有特定起作用的场景：它要和<code>^</code>和<code>$</code>搭配起来使用。默认情况下，<code>^</code>和<code>$</code>匹配的是文本的开始和结束，加上<code>m</code>修饰符，它们的含义就变成了行的开始和结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">`</span><br><span class="hljs-string">abc</span><br><span class="hljs-string">xyz</span><br><span class="hljs-string">`</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/xyz/</span>);<br><span class="hljs-comment">// [&quot;xyz&quot;, index: 5, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]</span><br><span class="hljs-string">`</span><br><span class="hljs-string">abc</span><br><span class="hljs-string">xyz</span><br><span class="hljs-string">`</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^xyz$/</span>);<br><span class="hljs-comment">// null</span><br><span class="hljs-string">`</span><br><span class="hljs-string">abc</span><br><span class="hljs-string">xyz</span><br><span class="hljs-string">`</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^xyz$/m</span>);<br><span class="hljs-comment">// [&quot;xyz&quot;, index: 5, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<h3 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h3><blockquote>
<p>这是ES2015的新特性。</p>
</blockquote>
<p><code>y</code>是<code>sticky</code>的缩写。<code>y</code>修饰符有和<code>g</code>修饰符重合的功能，它们都是全局匹配。所以重点在<code>sticky</code>上，怎么理解这个<code>粘连</code>呢？</p>
<p><code>g</code>修饰符不挑食，匹配完一个接着匹配下一个，对于文本的位置没有要求。但是<code>y</code>修饰符要求必须从文本的开始实施匹配，因为它会开启全局匹配，匹配到的文本的下一个字符就是下一次文本的开始。这就是所谓的粘连。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a bag with a tag has a mag&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\wag/g</span>);<br><span class="hljs-comment">// [&quot;bag&quot;, &quot;tag&quot;, &quot;mag&quot;]</span><br><span class="hljs-string">&#x27;a bag with a tag has a mag&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\wag/y</span>);<br><span class="hljs-comment">// null</span><br><span class="hljs-string">&#x27;bagtagmag&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\wag/y</span>);<br><span class="hljs-comment">// [&quot;bag&quot;, index: 0, input: &quot;bagtagmag&quot;, groups: undefined]</span><br><span class="hljs-string">&#x27;bagtagmag&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\wag/gy</span>);<br><span class="hljs-comment">// [&quot;bag&quot;, &quot;tag&quot;, &quot;mag&quot;]</span><br></code></pre></td></tr></table></figure>

<p>有人肯定发现了猫腻：你不是说<code>y</code>修饰符是全局匹配么？看上面的例子，单独一个<code>y</code>修饰符用match方法怎么并不是全局匹配呢？</p>
<p>诶，这里说来就话长了。</p>
<p>长话短说呢，就涉及到<code>y</code>修饰符的本质是什么。它的本质有二：</p>
<ul>
<li>全局匹配(先别着急打我)。</li>
<li>从文本的<code>lastIndex</code>位置开始新的匹配。lastIndex是什么？它是正则表达式的一个属性，如果是全局匹配，它用来标注下一次匹配的起始点。这才是粘连的本质所在。</li>
</ul>
<p>不知道你们发现什么了没有：<strong>lastIndex是正则表达式的一个属性</strong>。而上面例子中的match方法是作用在字符串上的，都没有lastIndex属性，休怪人家工作不上心。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\wag/y</span>;<br>reg.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;bagtagmag&#x27;</span>);<br><span class="hljs-comment">// [&quot;bag&quot;, index: 0, input: &quot;bagtagmag&quot;, groups: undefined]</span><br>reg.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;bagtagmag&#x27;</span>);<br><span class="hljs-comment">// [&quot;tag&quot;, index: 3, input: &quot;bagtagmag&quot;, groups: undefined]</span><br>reg.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;bagtagmag&#x27;</span>);<br><span class="hljs-comment">// [&quot;mag&quot;, index: 6, input: &quot;bagtagmag&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p>咱们换成正则方法exec，多次执行，正则的lastIndex在变，匹配的结果也在变。全局匹配无疑了吧。</p>
<h3 id="s修饰符"><a href="#s修饰符" class="headerlink" title="s修饰符"></a>s修饰符</h3><blockquote>
<p>这是ES2018的新特性。</p>
</blockquote>
<p><code>s</code>不是<code>dotAll</code>的缩写。<code>s</code>修饰符要和<code>.</code>搭配使用，默认情况下，<code>.</code>匹配除了换行符之外的任意单个字符，然而它还没有强大到无所不能的地步，所以正则索性给它开个挂。</p>
<p><code>s</code>修饰符的作用就是让<code>.</code>可以匹配任意单个字符。</p>
<p><code>s</code>是<code>singleline</code>的缩写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">`</span><br><span class="hljs-string">abc</span><br><span class="hljs-string">xyz</span><br><span class="hljs-string">`</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/c.x/</span>);<br><span class="hljs-comment">// null</span><br><span class="hljs-string">`</span><br><span class="hljs-string">abc</span><br><span class="hljs-string">xyz</span><br><span class="hljs-string">`</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/c.x/</span>s);<br><span class="hljs-comment">// [&quot;c↵x&quot;, index: 3, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<h3 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h3><blockquote>
<p>这是ES2015的新特性。</p>
</blockquote>
<p><code>u</code>是<code>unicode</code>的缩写。有一些Unicode字符超过一个字节，正则就无法正确的识别它们。<code>u</code>修饰符就是用来处理这些不常见的情况的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;𠮷&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^.$/</span>);<br><span class="hljs-comment">// null</span><br><span class="hljs-string">&#x27;𠮷&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^.$/u</span>);<br><span class="hljs-comment">// [&quot;𠮷&quot;, index: 0, input: &quot;𠮷&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure>

<p><code>𠮷</code>念<code>jí</code>，与<code>吉</code>同义。</p>
<blockquote>
<p>本文摘自 <a target="_blank" rel="noopener" href="https://github.com/veedrin/horseshoe">https://github.com/veedrin/horseshoe</a></p>
</blockquote>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/regex/">regex</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=638f3ad2a0f4de0012f03df8&amp;product=inline-share-buttons&amp;source=platform" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/02/05/regex-method/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Regular Expressions 正则表达式方法</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/20/git-rename-branch/"><span class="level-item">git 修改本地和远程分支名称</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#普通字符"><span class="level-left"><span class="level-item">1</span><span class="level-item">普通字符</span></span></a></li><li><a class="level is-mobile" href="#开始与结束"><span class="level-left"><span class="level-item">2</span><span class="level-item">开始与结束</span></span></a></li><li><a class="level is-mobile" href="#转义"><span class="level-left"><span class="level-item">3</span><span class="level-item">转义</span></span></a></li><li><a class="level is-mobile" href="#带反斜杠的元字符"><span class="level-left"><span class="level-item">4</span><span class="level-item">带反斜杠的元字符</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#b元字符"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">\b元字符</span></span></a></li><li><a class="level is-mobile" href="#d元字符"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">\d元字符</span></span></a></li><li><a class="level is-mobile" href="#s元字符"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">\s元字符</span></span></a></li><li><a class="level is-mobile" href="#w元字符"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">\w元字符</span></span></a></li><li><a class="level is-mobile" href="#负阴抱阳"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">负阴抱阳</span></span></a></li></ul></li><li><a class="level is-mobile" href="#道生一"><span class="level-left"><span class="level-item">5</span><span class="level-item">道生一</span></span></a></li><li><a class="level is-mobile" href="#量词"><span class="level-left"><span class="level-item">6</span><span class="level-item">量词</span></span></a></li><li><a class="level is-mobile" href="#贪婪模式与非贪婪模式"><span class="level-left"><span class="level-item">7</span><span class="level-item">贪婪模式与非贪婪模式</span></span></a></li><li><a class="level is-mobile" href="#字符组"><span class="level-left"><span class="level-item">8</span><span class="level-item">字符组</span></span></a></li><li><a class="level is-mobile" href="#捕获组与非捕获组"><span class="level-left"><span class="level-item">9</span><span class="level-item">捕获组与非捕获组</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#正则内捕获"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">正则内捕获</span></span></a></li><li><a class="level is-mobile" href="#正则外捕获"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">正则外捕获</span></span></a></li><li><a class="level is-mobile" href="#捕获命名"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">捕获命名</span></span></a></li></ul></li><li><a class="level is-mobile" href="#分支"><span class="level-left"><span class="level-item">10</span><span class="level-item">分支</span></span></a></li><li><a class="level is-mobile" href="#零宽断言"><span class="level-left"><span class="level-item">11</span><span class="level-item">零宽断言</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#零宽肯定先行断言"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">零宽肯定先行断言</span></span></a></li><li><a class="level is-mobile" href="#零宽肯定后行断言"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">零宽肯定后行断言</span></span></a></li><li><a class="level is-mobile" href="#零宽否定先行断言"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">零宽否定先行断言</span></span></a></li><li><a class="level is-mobile" href="#零宽否定后行断言"><span class="level-left"><span class="level-item">11.4</span><span class="level-item">零宽否定后行断言</span></span></a></li></ul></li><li><a class="level is-mobile" href="#修饰符"><span class="level-left"><span class="level-item">12</span><span class="level-item">修饰符</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#g修饰符"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">g修饰符</span></span></a></li><li><a class="level is-mobile" href="#i修饰符"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">i修饰符</span></span></a></li><li><a class="level is-mobile" href="#m修饰符"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">m修饰符</span></span></a></li><li><a class="level is-mobile" href="#y修饰符"><span class="level-left"><span class="level-item">12.4</span><span class="level-item">y修饰符</span></span></a></li><li><a class="level is-mobile" href="#s修饰符"><span class="level-left"><span class="level-item">12.5</span><span class="level-item">s修饰符</span></span></a></li><li><a class="level is-mobile" href="#u修饰符"><span class="level-left"><span class="level-item">12.6</span><span class="level-item">u修饰符</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/avatar.png" alt="Adi Huang"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Adi Huang</p><p class="is-size-6 is-block">Web Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Ningbo, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">85</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">28</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/hd1987" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/hd1987"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Npmjs" href="https://www.npmjs.com/~adihuang"><i class="fa-brands fa-npm"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag">36</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cli/"><span class="tag">cli</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html/"><span class="tag">html</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sass/"><span class="tag">sass</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nodejs/"><span class="tag">nodejs</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/npm/"><span class="tag">npm</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/terminal/"><span class="tag">terminal</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ios/"><span class="tag">ios</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/retina/"><span class="tag">retina</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/homebrew/"><span class="tag">homebrew</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/meta/"><span class="tag">meta</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/markdown/"><span class="tag">markdown</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/php/"><span class="tag">php</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/regex/"><span class="tag">regex</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/wechat/"><span class="tag">wechat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zepto/"><span class="tag">zepto</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/react/"><span class="tag">react</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nvm/"><span class="tag">nvm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sketch/"><span class="tag">sketch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vagrant/"><span class="tag">vagrant</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vim/"><span class="tag">vim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webpack/"><span class="tag">webpack</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/logo.svg" alt="AdiHuang" height="28"></a><p class="is-size-7"><span>&copy; 2024 AdiHuang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/hd1987/hd1987.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>